; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26726.0 

	TITLE	C:\Dev\Tetris\src\board.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$allocator@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$allocator@H@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ; std::vector<int,std::allocator<int> >::resize
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::size
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	?_Udefault@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHI@Z ; std::vector<int,std::allocator<int> >::_Udefault
PUBLIC	?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	??0Matrix@math@core@@QAE@XZ			; core::math::Matrix::Matrix
PUBLIC	?Resize@Matrix@math@core@@QAEXHH@Z		; core::math::Matrix::Resize
PUBLIC	?Clear@Matrix@math@core@@QAEXXZ			; core::math::Matrix::Clear
PUBLIC	?SetElements@Matrix@math@core@@QAEXHHH@Z	; core::math::Matrix::SetElements
PUBLIC	?CopyElements@Matrix@math@core@@QAEXHHH@Z	; core::math::Matrix::CopyElements
PUBLIC	?GetValue@Matrix@math@core@@QBEHHH@Z		; core::math::Matrix::GetValue
PUBLIC	??1Matrix@math@core@@QAE@XZ			; core::math::Matrix::~Matrix
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
PUBLIC	?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEXPBH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Seek_to
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
PUBLIC	?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped
PUBLIC	??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
PUBLIC	??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@00@Z ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	?GetLines@Stats@gameplay@core@@QAEPA_NXZ	; core::gameplay::Stats::GetLines
PUBLIC	?SetPendingLineCount@Stats@gameplay@core@@QAEXH@Z ; core::gameplay::Stats::SetPendingLineCount
PUBLIC	??0Board@gameplay@core@@QAE@HHHH@Z		; core::gameplay::Board::Board
PUBLIC	?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z	; core::gameplay::Board::DrawCell
PUBLIC	?DrawBoard@Board@gameplay@core@@QAEXHH@Z	; core::gameplay::Board::DrawBoard
PUBLIC	?IsRowFilled@Board@gameplay@core@@QAE_NH@Z	; core::gameplay::Board::IsRowFilled
PUBLIC	?IsRowEmpty@Board@gameplay@core@@QAE_NH@Z	; core::gameplay::Board::IsRowEmpty
PUBLIC	?FindLines@Board@gameplay@core@@QAEXPAVStats@23@@Z ; core::gameplay::Board::FindLines
PUBLIC	?ClearLines@Board@gameplay@core@@QAEXPAVStats@23@@Z ; core::gameplay::Board::ClearLines
PUBLIC	?GetCellValue@Board@gameplay@core@@QBEHHH@Z	; core::gameplay::Board::GetCellValue
PUBLIC	??0Color@core@@QAE@ABV01@@Z			; core::Color::Color
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z ; std::_Uninitialized_value_construct_n<int *,unsigned int,std::allocator<int> >
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,0>
PUBLIC	??$_Fill_unchecked@PAHH@std@@YAXPAH0ABH@Z	; std::_Fill_unchecked<int *,int>
PUBLIC	??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0@Z ; std::_Idl_distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>
PUBLIC	??$_Idl_distance1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>
PUBLIC	??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@H@Z ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int,0>
PUBLIC	??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_unchecked<int *,int *>
PUBLIC	??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH$0A@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@ABQAH@Z ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *,0>
PUBLIC	??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<int *,unsigned int,std::allocator<int> >
PUBLIC	??$_Destroy_range1@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<int> >
PUBLIC	??$_Min_value@I@std@@YAABIABI0@Z		; std::_Min_value<unsigned int>
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
PUBLIC	??$_Adl_verify_range1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ; std::_Adl_verify_range1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Fill_memset_is_safe@PAHH@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAHABH@Z ; std::_Fill_memset_is_safe<int *,int>
PUBLIC	??$_Fill_unchecked1@PAHH@std@@YAXPAH0ABHU?$integral_constant@_N$0A@@0@@Z ; std::_Fill_unchecked1<int *,int>
PUBLIC	??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ; std::_Ptr_copy_cat<int,int>
PUBLIC	??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<int *,int *>
PUBLIC	??$_Zero_range@PAH@std@@YAPAHQAH0@Z		; std::_Zero_range<int *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_unwrapped@H@std@@YAPAHQAH@Z		; std::_Get_unwrapped<int>
PUBLIC	??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z	; std::_Idl_distance<int *,int *>
PUBLIC	??$_Idl_distance1@PAHPAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z ; std::_Idl_distance1<int *,int *>
PUBLIC	??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z	; std::_Get_unwrapped_n<int,int,0>
PUBLIC	??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ; std::_Ptr_move_cat<int,int>
PUBLIC	??$_Uninitialized_move_al_unchecked@HHV?$allocator@H@std@@@std@@YAPAHQAH00AAV?$allocator@H@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_move_al_unchecked<int,int,std::allocator<int> >
PUBLIC	??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z		; std::_Seek_wrapped<int>
PUBLIC	??$_Const_cast@$$CBH@std@@YAPAHPBH@Z		; std::_Const_cast<int const >
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@ ; `string'
PUBLIC	??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__wassert:PROC
EXTRN	?Instance@Graphics@graphics@core@@SAPAV123@XZ:PROC ; core::graphics::Graphics::Instance
EXTRN	?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z:PROC ; core::graphics::Graphics::DrawFillRect
EXTRN	?DrawRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z:PROC ; core::graphics::Graphics::DrawRect
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	?s_base@Palette@core@@2QBVColor@2@B:BYTE	; core::Palette::s_base
EXTRN	?s_light@Palette@core@@2QBVColor@2@B:BYTE	; core::Palette::s_light
EXTRN	?s_dark@Palette@core@@2QBVColor@2@B:BYTE	; core::Palette::s_dark
EXTRN	___security_cookie:DWORD
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
CONST	SEGMENT
??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@ DB 'r'
	DB	00H, 'o', 00H, 'w', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'o'
	DB	00H, 'w', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H
	DB	'r', 00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'c'
	DB	00H, 'o', 00H, 'l', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
CONST	SEGMENT
??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'd', 00H, 'e', 00H, 'v', 00H, '\', 00H
	DB	't', 00H, 'e', 00H, 't', 00H, 'r', 00H, 'i', 00H, 's', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'm', 00H, 'a', 00H
	DB	't', 00H, 'h', 00H, '\', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'x', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Board@gameplay@core@@QAE@HHHH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Board@gameplay@core@@QAE@HHHH@Z$0
__ehfuncinfo$??0Board@gameplay@core@@QAE@HHHH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Board@gameplay@core@@QAE@HHHH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));
; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
  00004	56		 push	 esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00005	8b 74 24 10	 mov	 esi, DWORD PTR __Dest$[esp]
  00009	57		 push	 edi
  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000e	2b f8		 sub	 edi, eax
  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 2405 : 	}

  00020	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Const_cast@$$CBH@std@@YAPAHPBH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Const_cast@$$CBH@std@@YAPAHPBH@Z PROC		; std::_Const_cast<int const >, COMDAT

; 387  : 	return (const_cast<remove_const_t<_Ty> *>(_Ptr));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]

; 388  : 	}

  00004	c3		 ret	 0
??$_Const_cast@$$CBH@std@@YAPAHPBH@Z ENDP		; std::_Const_cast<int const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z PROC		; std::_Seek_wrapped<int>, COMDAT

; 872  : 	_It = _UIt;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __It$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __UIt$[esp-4]
  00008	89 08		 mov	 DWORD PTR [eax], ecx

; 873  : 	}

  0000a	c3		 ret	 0
??$_Seek_wrapped@H@std@@YAXAAPAHQAH@Z ENDP		; std::_Seek_wrapped<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@HHV?$allocator@H@std@@@std@@YAPAHQAH00AAV?$allocator@H@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked@HHV?$allocator@H@std@@@std@@YAPAHQAH00AAV?$allocator@H@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<int,int,std::allocator<int> >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00004	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00005	8b 74 24 10	 mov	 esi, DWORD PTR __Dest$[esp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 243  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000e	2b f8		 sub	 edi, eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 244  : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 245  : 	}

  00020	c3		 ret	 0
??$_Uninitialized_move_al_unchecked@HHV?$allocator@H@std@@@std@@YAPAHQAH00AAV?$allocator@H@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<int,int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z PROC ; std::_Ptr_move_cat<int,int>, COMDAT

; 1087 : 	return {};

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1088 : 	}

  00004	c3		 ret	 0
??$_Ptr_move_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ENDP ; std::_Ptr_move_cat<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z PROC	; std::_Get_unwrapped_n<int,int,0>, COMDAT

; 809  : 	return (_Src);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Src$[esp-4]

; 810  : 	}

  00004	c3		 ret	 0
??$_Get_unwrapped_n@HH$0A@@std@@YAPAHQAHH@Z ENDP	; std::_Get_unwrapped_n<int,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Idl_distance1@PAHPAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Idl_distance1@PAHPAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<int *,int *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000c	c1 f8 02	 sar	 eax, 2

; 969  : 	}

  0000f	c3		 ret	 0
??$_Idl_distance1@PAHPAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z PROC		; std::_Idl_distance<int *,int *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000c	c1 f8 02	 sar	 eax, 2

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
; 976  : 	}

  0000f	c3		 ret	 0
??$_Idl_distance@PAHPAH@std@@YAHABQAH0@Z ENDP		; std::_Idl_distance<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Get_unwrapped@H@std@@YAPAHQAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Get_unwrapped@H@std@@YAPAHQAH@Z PROC		; std::_Get_unwrapped<int>, COMDAT

; 663  : 	return (_Ptr);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]

; 664  : 	}

  00004	c3		 ret	 0
??$_Get_unwrapped@H@std@@YAPAHQAH@Z ENDP		; std::_Get_unwrapped<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Bytes$[esp-4]

; 94   : 	if (_Block_size <= _Bytes)

  00004	83 ca ff	 or	 edx, -1
  00007	8d 48 23	 lea	 ecx, DWORD PTR [eax+35]
  0000a	3b c8		 cmp	 ecx, eax
  0000c	0f 46 ca	 cmovbe	 ecx, edx

; 52   : 		return (::operator new(_Bytes));

  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 95   : 		{	// add overflow, try allocating all of memory and assume the
; 96   : 			// allocation function will throw bad_alloc
; 97   : 		_Block_size = static_cast<size_t>(-1);
; 98   : 		}
; 99   : 
; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00015	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00017	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0001a	85 c9		 test	 ecx, ecx
  0001c	74 0a		 je	 SHORT $LN7@Allocate_m

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  0001e	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00021	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00024	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 105  : 
; 106  :   #ifdef _DEBUG
; 107  : 	static_cast<uintptr_t *>(_Ptr)[-2] = _Big_allocation_sentinel;
; 108  :   #endif /* _DEBUG */
; 109  : 	return (_Ptr);
; 110  : 	}

  00027	c3		 ret	 0
$LN7@Allocate_m:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00028	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
;	COMDAT ??$_Zero_range@PAH@std@@YAPAHQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAH@std@@YAPAHQAH0@Z PROC		; std::_Zero_range<int *>, COMDAT

; 311  : 	char * const _First_ch = reinterpret_cast<char *>(_First);
; 312  : 	char * const _Last_ch = reinterpret_cast<char *>(_Last);
; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00000	8b 54 24 04	 mov	 edx, DWORD PTR __First$[esp-4]
  00004	8b 4c 24 08	 mov	 ecx, DWORD PTR __Last$[esp-4]
  00008	2b ca		 sub	 ecx, edx
  0000a	51		 push	 ecx
  0000b	6a 00		 push	 0
  0000d	52		 push	 edx
  0000e	e8 00 00 00 00	 call	 _memset

; 314  : 	return (_Last);

  00013	8b 44 24 14	 mov	 eax, DWORD PTR __Last$[esp+8]
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH

; 315  : 	}

  0001a	c3		 ret	 0
??$_Zero_range@PAH@std@@YAPAHQAH0@Z ENDP		; std::_Zero_range<int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<int *,int *>, COMDAT

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]

; 2424 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable

  00004	56		 push	 esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00005	8b 74 24 10	 mov	 esi, DWORD PTR __Dest$[esp]

; 2424 : 	{	// copy [_First, _Last) to [_Dest, ...), pointers to trivially copyable

  00009	57		 push	 edi

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000e	2b f8		 sub	 edi, eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]

; 2425 : 	return (_Copy_memmove(_First, _Last, _Dest));

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 2426 : 	}

  00020	c3		 ret	 0
??$_Copy_unchecked1@PAHPAH@std@@YAPAHPAH00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z PROC ; std::_Ptr_copy_cat<int,int>, COMDAT

; 1070 : 	return {};

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]

; 1071 : 	}

  00004	c3		 ret	 0
??$_Ptr_copy_cat@HH@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAH0@Z ENDP ; std::_Ptr_copy_cat<int,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Fill_unchecked1@PAHH@std@@YAXPAH0ABHU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_unchecked1@PAHH@std@@YAXPAH0ABHU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Fill_unchecked1<int *,int>, COMDAT

; 2901 : 	{	// copy _Val through [_First, _Last), no special optimization

  00000	53		 push	 ebx

; 2902 : 	for (; _First != _Last; ++_First)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]
  00005	33 c9		 xor	 ecx, ecx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Last$[esp+4]
  0000c	33 d2		 xor	 edx, edx
  0000e	2b eb		 sub	 ebp, ebx
  00010	83 c5 03	 add	 ebp, 3
  00013	c1 ed 02	 shr	 ebp, 2
  00016	3b 5c 24 10	 cmp	 ebx, DWORD PTR __Last$[esp+4]
  0001a	0f 47 e9	 cmova	 ebp, ecx
  0001d	85 ed		 test	 ebp, ebp
  0001f	74 52		 je	 SHORT $LN3@Fill_unche
  00021	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  00025	57		 push	 edi
  00026	83 fd 04	 cmp	 ebp, 4
  00029	72 32		 jb	 SHORT $LN9@Fill_unche

; 2903 : 		*_First = _Val;

  0002b	8b 38		 mov	 edi, DWORD PTR [eax]
  0002d	8d 4b fc	 lea	 ecx, DWORD PTR [ebx-4]
  00030	8d 0c a9	 lea	 ecx, DWORD PTR [ecx+ebp*4]
  00033	3b d8		 cmp	 ebx, eax
  00035	77 04		 ja	 SHORT $LN10@Fill_unche

; 2902 : 	for (; _First != _Last; ++_First)

  00037	3b c8		 cmp	 ecx, eax
  00039	73 22		 jae	 SHORT $LN9@Fill_unche
$LN10@Fill_unche:
  0003b	56		 push	 esi
  0003c	8b f5		 mov	 esi, ebp
  0003e	83 e6 fc	 and	 esi, -4			; fffffffcH
$LL4@Fill_unche:
  00041	83 c2 04	 add	 edx, 4
  00044	3b d6		 cmp	 edx, esi
  00046	75 f9		 jne	 SHORT $LL4@Fill_unche
  00048	c1 e6 02	 shl	 esi, 2
  0004b	8b c7		 mov	 eax, edi
  0004d	8b ce		 mov	 ecx, esi
  0004f	8b fb		 mov	 edi, ebx
  00051	c1 e9 02	 shr	 ecx, 2
  00054	03 de		 add	 ebx, esi
  00056	f3 ab		 rep stosd
  00058	8b 44 24 1c	 mov	 eax, DWORD PTR __Val$[esp+12]
  0005c	5e		 pop	 esi
$LN9@Fill_unche:
  0005d	5f		 pop	 edi
  0005e	3b d5		 cmp	 edx, ebp
  00060	74 11		 je	 SHORT $LN3@Fill_unche
$LL8@Fill_unche:

; 2903 : 		*_First = _Val;

  00062	8b 00		 mov	 eax, DWORD PTR [eax]
  00064	8d 5b 04	 lea	 ebx, DWORD PTR [ebx+4]
  00067	42		 inc	 edx
  00068	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  0006b	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0006f	3b d5		 cmp	 edx, ebp
  00071	75 ef		 jne	 SHORT $LL8@Fill_unche
$LN3@Fill_unche:
  00073	5d		 pop	 ebp

; 2904 : 	}

  00074	5b		 pop	 ebx
  00075	c3		 ret	 0
??$_Fill_unchecked1@PAHH@std@@YAXPAH0ABHU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Fill_unchecked1<int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Fill_memset_is_safe@PAHH@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAHABH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Fill_memset_is_safe@PAHH@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAHABH@Z PROC ; std::_Fill_memset_is_safe<int *,int>, COMDAT

; 2895 : 	return {};

  00000	32 c0		 xor	 al, al

; 2896 : 	}

  00002	c3		 ret	 0
??$_Fill_memset_is_safe@PAHH@std@@YA?AU?$integral_constant@_N$0A@@0@ABQAHABH@Z ENDP ; std::_Fill_memset_is_safe<int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Adl_verify_range1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Adl_verify_range1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Adl_verify_range1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 610  : 	}

  00000	c3		 ret	 0
??$_Adl_verify_range1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Adl_verify_range1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,int *,std::allocator<int> >, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00004	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00005	8b 74 24 10	 mov	 esi, DWORD PTR __Dest$[esp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 251  : 	{	// move [_First, _Last) to raw _Dest, using _Al

  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000e	2b f8		 sub	 edi, eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 260  : 	return (_Dest);

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 261  : 	}

  00020	c3		 ret	 0
??$_Uninitialized_move@PAHPAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,int *,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 181  :  #if defined(_M_IX86) || defined(_M_X64)
; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Bytes$[esp-4]
  00004	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000a	72 29		 jb	 SHORT $LN2@Allocate

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0000c	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  0000f	83 ca ff	 or	 edx, -1
  00012	3b c1		 cmp	 eax, ecx
  00014	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001d	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  0001f	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00022	85 c9		 test	 ecx, ecx
  00024	74 0a		 je	 SHORT $LN11@Allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00026	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  00029	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0002c	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 194  : 	}

  0002f	c3		 ret	 0
$LN11@Allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00030	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN2@Allocate:

; 183  : 		{	// boost the alignment of big allocations to help autovectorization
; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));
; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  00035	85 c9		 test	 ecx, ecx
  00037	74 09		 je	 SHORT $LN3@Allocate

; 52   : 		return (::operator new(_Bytes));

  00039	89 4c 24 04	 mov	 DWORD PTR __Bytes$[esp-4], ecx
  0003d	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
$LN3@Allocate:

; 189  : 		{
; 190  : 		return (_Traits::_Allocate(_Bytes));
; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  00042	33 c0		 xor	 eax, eax

; 194  : 	}

  00044	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 24   : 	constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   : 	size_t _Result = _Count * _Ty_size;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __Count$[esp-4]

; 26   : 	if (_Max_possible < _Count)

  00004	83 ca ff	 or	 edx, -1
  00007	81 f9 ff ff ff
	3f		 cmp	 ecx, 1073741823		; 3fffffffH
  0000d	8d 04 8d 00 00
	00 00		 lea	 eax, DWORD PTR [ecx*4]
  00014	0f 47 c2	 cmova	 eax, edx

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);
; 30   : 		}
; 31   : 
; 32   : 	return (_Result);
; 33   : 	}

  00017	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\utility
;	COMDAT ??$_Min_value@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Min_value@I@std@@YAABIABI0@Z PROC			; std::_Min_value<unsigned int>, COMDAT

; 24   : 	return (_Right < _Left ? _Right : _Left);

  00000	8b 54 24 08	 mov	 edx, DWORD PTR __Right$[esp-4]
  00004	8b 44 24 04	 mov	 eax, DWORD PTR __Left$[esp-4]
  00008	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0000a	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0000c	0f 42 c2	 cmovb	 eax, edx

; 25   : 	}

  0000f	c3		 ret	 0
??$_Min_value@I@std@@YAABIABI0@Z ENDP			; std::_Min_value<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<int> >, COMDAT

; 1146 : 		// nothing to do
; 1147 : 	}

  00000	c3		 ret	 0
??$_Destroy_range1@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<int *,unsigned int,std::allocator<int> >, COMDAT

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	56		 push	 esi

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00005	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]

; 335  : 	{	// value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

  00009	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000a	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	57		 push	 edi
  00012	6a 00		 push	 0
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001d	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 337  : 	}

  00022	c3		 ret	 0
??$_Uninitialized_value_construct_n1@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<int *,unsigned int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH$0A@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@ABQAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH$0A@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@ABQAH@Z PROC ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *,0>, COMDAT
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 219  : 		_Ptr = _Const_cast(_It);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __UIt$[esp-4]
  00004	8b 08		 mov	 ecx, DWORD PTR [eax]
  00006	8b 44 24 04	 mov	 eax, DWORD PTR __It$[esp-4]
  0000a	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 858  : 	}

  0000c	c3		 ret	 0
??$_Seek_wrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH$0A@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@ABQAH@Z ENDP ; std::_Seek_wrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_unchecked<int *,int *>, COMDAT

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __First$[esp-4]

; 2432 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00004	56		 push	 esi

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00005	8b 74 24 10	 mov	 esi, DWORD PTR __Dest$[esp]

; 2432 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00009	57		 push	 edi

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000a	8b 7c 24 10	 mov	 edi, DWORD PTR __Last$[esp+4]
  0000e	2b f8		 sub	 edi, eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	57		 push	 edi
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	e8 00 00 00 00	 call	 _memmove
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001b	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]

; 2433 : 		// note: _Copy_unchecked is called directly from elsewhere in the STL
; 2434 : 	return (_Copy_unchecked1(_First, _Last, _Dest, _Ptr_copy_cat(_First, _Dest)));

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi

; 2435 : 	}

  00020	c3		 ret	 0
??$_Copy_unchecked@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_unchecked<int *,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@H@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__Off$ = 12						; size = 4
??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@H@Z PROC ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int,0>, COMDAT

; 761  : 	using _IDiff = _Iter_diff_t<_Iter>;
; 762  : 	using _CDiff = common_type_t<_Diff, _IDiff>;
; 763  : 	const auto _COff = static_cast<_CDiff>(_Off);
; 764  : 
; 765  : 	_STL_ASSERT(_COff <= static_cast<_CDiff>(_Max_possible_v<_IDiff>)
; 766  : 		&& (is_unsigned_v<_Diff> || static_cast<_CDiff>(_Min_possible_v<_IDiff>) <= _COff),
; 767  : 		"integer overflow");
; 768  : 	(void) _COff;
; 769  : 
; 770  : 	_It._Verify_offset(static_cast<_IDiff>(_Off));
; 771  : 	return (_It._Unwrapped());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __It$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]

; 772  : 	}

  00006	c3		 ret	 0
??$_Get_unwrapped_n@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@H@Z ENDP ; std::_Get_unwrapped_n<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Idl_distance1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Idl_distance1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z PROC ; std::_Idl_distance1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000c	c1 f8 02	 sar	 eax, 2

; 969  : 	}

  0000f	c3		 ret	 0
??$_Idl_distance1@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0Urandom_access_iterator_tag@0@@Z ENDP ; std::_Idl_distance1<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0@Z PROC ; std::_Idl_distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>, COMDAT

; 968  : 	return (static_cast<_Iter_diff_t<_Checked>>(_Last - _First));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00008	8b 00		 mov	 eax, DWORD PTR [eax]
  0000a	2b 01		 sub	 eax, DWORD PTR [ecx]
  0000c	c1 f8 02	 sar	 eax, 2

; 975  : 	return (_Idl_distance1<_Checked>(_First, _Last, _Iter_cat_t<_Iter>()));
; 976  : 	}

  0000f	c3		 ret	 0
??$_Idl_distance@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@PAH@std@@YAHABQAH0@Z ENDP ; std::_Idl_distance<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Fill_unchecked@PAHH@std@@YAXPAH0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Fill_unchecked@PAHH@std@@YAXPAH0ABH@Z PROC		; std::_Fill_unchecked<int *,int>, COMDAT

; 2916 : 	{	// copy _Val through [_First, _Last), choose optimization

  00000	53		 push	 ebx

; 2917 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]
  00005	33 c9		 xor	 ecx, ecx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Last$[esp+4]
  0000c	33 d2		 xor	 edx, edx
  0000e	2b eb		 sub	 ebp, ebx
  00010	83 c5 03	 add	 ebp, 3
  00013	c1 ed 02	 shr	 ebp, 2
  00016	3b 5c 24 10	 cmp	 ebx, DWORD PTR __Last$[esp+4]
  0001a	0f 47 e9	 cmova	 ebp, ecx

; 2902 : 	for (; _First != _Last; ++_First)

  0001d	85 ed		 test	 ebp, ebp
  0001f	74 52		 je	 SHORT $LN7@Fill_unche
  00021	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  00025	57		 push	 edi
  00026	83 fd 04	 cmp	 ebp, 4
  00029	72 32		 jb	 SHORT $LN13@Fill_unche

; 2903 : 		*_First = _Val;

  0002b	8b 38		 mov	 edi, DWORD PTR [eax]

; 2917 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

  0002d	8d 4b fc	 lea	 ecx, DWORD PTR [ebx-4]
  00030	8d 0c a9	 lea	 ecx, DWORD PTR [ecx+ebp*4]
  00033	3b d8		 cmp	 ebx, eax
  00035	77 04		 ja	 SHORT $LN14@Fill_unche
  00037	3b c8		 cmp	 ecx, eax
  00039	73 22		 jae	 SHORT $LN13@Fill_unche
$LN14@Fill_unche:
  0003b	56		 push	 esi
  0003c	8b f5		 mov	 esi, ebp
  0003e	83 e6 fc	 and	 esi, -4			; fffffffcH
$LL8@Fill_unche:

; 2902 : 	for (; _First != _Last; ++_First)

  00041	83 c2 04	 add	 edx, 4
  00044	3b d6		 cmp	 edx, esi
  00046	75 f9		 jne	 SHORT $LL8@Fill_unche

; 2917 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

  00048	c1 e6 02	 shl	 esi, 2
  0004b	8b c7		 mov	 eax, edi
  0004d	8b ce		 mov	 ecx, esi
  0004f	8b fb		 mov	 edi, ebx
  00051	c1 e9 02	 shr	 ecx, 2
  00054	03 de		 add	 ebx, esi
  00056	f3 ab		 rep stosd
  00058	8b 44 24 1c	 mov	 eax, DWORD PTR __Val$[esp+12]
  0005c	5e		 pop	 esi
$LN13@Fill_unche:

; 2902 : 	for (; _First != _Last; ++_First)

  0005d	5f		 pop	 edi
  0005e	3b d5		 cmp	 edx, ebp
  00060	74 11		 je	 SHORT $LN7@Fill_unche
$LL12@Fill_unche:

; 2903 : 		*_First = _Val;

  00062	8b 00		 mov	 eax, DWORD PTR [eax]

; 2917 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

  00064	8d 5b 04	 lea	 ebx, DWORD PTR [ebx+4]

; 2902 : 	for (; _First != _Last; ++_First)

  00067	42		 inc	 edx

; 2903 : 		*_First = _Val;

  00068	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  0006b	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0006f	3b d5		 cmp	 edx, ebp
  00071	75 ef		 jne	 SHORT $LL12@Fill_unche
$LN7@Fill_unche:
  00073	5d		 pop	 ebp

; 2918 : 	}

  00074	5b		 pop	 ebx
  00075	c3		 ret	 0
??$_Fill_unchecked@PAHH@std@@YAXPAH0ABH@Z ENDP		; std::_Fill_unchecked<int *,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,0>, COMDAT

; 643  : 	return (_It._Unwrapped());

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __It$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]

; 644  : 	}

  00006	c3		 ret	 0
??$_Get_unwrapped@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@$0A@@std@@YAPAHABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 616  : 	_Adl_verify_range1(_First, _Last, bool_constant<_Range_verifiable_v<_Iter, _Sentinel>>{});
; 617  : 	}

  00000	c3		 ret	 0
??$_Adl_verify_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YAXABV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR __Bytes$[esp-4]
  00004	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0000a	72 19		 jb	 SHORT $LN15@Deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0000c	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]
  00010	83 c1 23	 add	 ecx, 35			; 00000023H
  00013	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00016	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00018	83 c0 fc	 add	 eax, -4			; fffffffcH
  0001b	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  0001e	76 09		 jbe	 SHORT $LN13@Deallocate
  00020	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
$LN15@Deallocate:

; 200  :  #if defined(_M_IX86) || defined(_M_X64)
; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00025	8b 54 24 04	 mov	 edx, DWORD PTR __Ptr$[esp-4]
$LN13@Deallocate:

; 202  : 		{	// boost the alignment of big allocations to help autovectorization
; 203  : 		_Adjust_manually_vector_aligned(_Ptr, _Bytes);
; 204  : 		}
; 205  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 206  : 
; 207  : 	::operator delete(_Ptr, _Bytes);

  00029	89 4c 24 08	 mov	 DWORD PTR __Bytes$[esp-4], ecx
  0002d	89 54 24 04	 mov	 DWORD PTR __Ptr$[esp-4], edx
  00031	e9 00 00 00 00	 jmp	 ??3@YAXPAXI@Z		; operator delete
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 1155 : 		// note that this is an optimization for debug mode codegen;
; 1156 : 		// in release mode the BE removes all of this
; 1157 : 	using _Val = typename _Alloc::value_type;
; 1158 : 	_Destroy_range1(_First, _Last, _Al, bool_constant<conjunction_v<
; 1159 : 		is_trivially_destructible<_Val>,
; 1160 : 		_Uses_default_destroy<_Alloc, _Val *>>>{});
; 1161 : 	}

  00000	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAH0AAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_value_construct_n<int *,unsigned int,std::allocator<int> >, COMDAT

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00004	56		 push	 esi

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00005	8b 74 24 08	 mov	 esi, DWORD PTR __First$[esp]

; 343  : 	{	// value-initialize _Count objects to raw _First, using _Al

  00009	57		 push	 edi

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000a	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	57		 push	 edi
  00012	6a 00		 push	 0
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001d	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]

; 344  : 	return (_Uninitialized_value_construct_n1(_First, _Count, _Al,

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 345  : 		bool_constant<conjunction_v<_Use_memset_value_construct_t<_FwdIt>,
; 346  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{}));
; 347  : 	}

  00022	c3		 ret	 0
??$_Uninitialized_value_construct_n@PAHIV?$allocator@H@std@@@std@@YAPAHPAHIAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_value_construct_n<int *,unsigned int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 279  : 		}

  00006	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 279  : 		}

  00016	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??$_Resize@V<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIV<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@Z
_TEXT	SEGMENT
tv951 = 8						; size = 4
__Newsize$ = 8						; size = 4
__Udefault_or_fill$ = 12				; size = 4
??$_Resize@V<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIV<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@Z PROC ; std::vector<int,std::allocator<int> >::_Resize<<lambda_4f2fd6a84b983411848f0e0333d0ea32> >, COMDAT
; _this$ = ecx

; 1428 : 		{	// trim or append elements, provide strong guarantee

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  00003	8b 74 24 10	 mov	 esi, DWORD PTR __Newsize$[esp+8]
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  0000a	8b 5f 04	 mov	 ebx, DWORD PTR [edi+4]
  0000d	8b eb		 mov	 ebp, ebx
  0000f	8b 07		 mov	 eax, DWORD PTR [edi]
  00011	2b e8		 sub	 ebp, eax

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00013	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00016	2b c8		 sub	 ecx, eax

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00018	c1 fd 02	 sar	 ebp, 2

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0001b	c1 f9 02	 sar	 ecx, 2

; 1429 : 		const size_type _Oldsize = size();
; 1430 : 		const size_type _Oldcapacity = capacity();
; 1431 : 
; 1432 : 		if (_Newsize > _Oldcapacity)

  0001e	3b f1		 cmp	 esi, ecx
  00020	0f 86 ef 00 00
	00		 jbe	 $LN2@Resize

; 1433 : 			{	// reallocate
; 1434 : 			if (_Newsize > max_size())

  00026	81 fe ff ff ff
	3f		 cmp	 esi, 1073741823		; 3fffffffH
  0002c	0f 87 14 01 00
	00		 ja	 $LN337@Resize

; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00032	8b d1		 mov	 edx, ecx
  00034	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH
  00039	d1 ea		 shr	 edx, 1
  0003b	2b c2		 sub	 eax, edx
  0003d	3b c8		 cmp	 ecx, eax
  0003f	76 04		 jbe	 SHORT $LN56@Resize

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow

  00041	8b c6		 mov	 eax, esi
  00043	eb 08		 jmp	 SHORT $LN57@Resize
$LN56@Resize:

; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00045	8d 04 0a	 lea	 eax, DWORD PTR [edx+ecx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  00048	3b c6		 cmp	 eax, esi
  0004a	0f 42 c6	 cmovb	 eax, esi
$LN57@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 25   : 	size_t _Result = _Count * _Ty_size;

  0004d	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00054	89 4c 24 14	 mov	 DWORD PTR tv951[esp+12], ecx

; 26   : 	if (_Max_possible < _Count)

  00058	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  0005d	76 05		 jbe	 SHORT $LN92@Resize

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  0005f	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00062	eb 08		 jmp	 SHORT $LN333@Resize
$LN92@Resize:
  00064	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0006a	72 27		 jb	 SHORT $LN95@Resize
$LN333@Resize:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0006c	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  0006f	83 ca ff	 or	 edx, -1
  00072	3b c1		 cmp	 eax, ecx
  00074	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0007d	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00080	85 c0		 test	 eax, eax
  00082	0f 84 c3 00 00
	00		 je	 $LN244@Resize

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00088	8d 58 23	 lea	 ebx, DWORD PTR [eax+35]
  0008b	83 e3 e0	 and	 ebx, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0008e	89 43 fc	 mov	 DWORD PTR [ebx-4], eax

; 184  : 		return (_Allocate_manually_vector_aligned<_Traits>(_Bytes));

  00091	eb 13		 jmp	 SHORT $LN94@Resize
$LN95@Resize:

; 185  : 		}
; 186  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 187  : 
; 188  : 	if (_Bytes != 0)

  00093	85 c9		 test	 ecx, ecx
  00095	74 0d		 je	 SHORT $LN96@Resize

; 52   : 		return (::operator new(_Bytes));

  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0009d	83 c4 04	 add	 esp, 4

; 190  : 		return (_Traits::_Allocate(_Bytes));

  000a0	8b d8		 mov	 ebx, eax
  000a2	eb 02		 jmp	 SHORT $LN94@Resize
$LN96@Resize:

; 191  : 		}
; 192  : 
; 193  : 	return (nullptr);

  000a4	33 db		 xor	 ebx, ebx
$LN94@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000a6	8b c6		 mov	 eax, esi
  000a8	2b c5		 sub	 eax, ebp
  000aa	c1 e0 02	 shl	 eax, 2
  000ad	50		 push	 eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1442 : 			const pointer _Appended_first = _Newvec + _Oldsize;

  000ae	8d 04 ab	 lea	 eax, DWORD PTR [ebx+ebp*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  000b1	6a 00		 push	 0
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 _memset
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2399 : 	const char * const _First_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_First));

  000b9	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 2400 : 	const char * const _Last_ch = const_cast<const char *>(reinterpret_cast<const volatile char *>(_Last));
; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));
; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  000bb	8b 47 04	 mov	 eax, DWORD PTR [edi+4]
  000be	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  000c0	50		 push	 eax
  000c1	51		 push	 ecx
  000c2	53		 push	 ebx
  000c3	e8 00 00 00 00	 call	 _memmove
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1898 : 		if (this->_Myfirst() != pointer())

  000c8	8b 07		 mov	 eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  000ca	83 c4 18	 add	 esp, 24			; 00000018H
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1898 : 		if (this->_Myfirst() != pointer())

  000cd	85 c0		 test	 eax, eax
  000cf	74 2c		 je	 SHORT $LN248@Resize

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  000d1	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  000d4	2b c8		 sub	 ecx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  000d6	83 e1 fc	 and	 ecx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  000d9	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  000df	72 12		 jb	 SHORT $LN247@Resize

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  000e1	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  000e4	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000e7	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000e9	83 c0 fc	 add	 eax, -4			; fffffffcH
  000ec	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  000ef	77 5a		 ja	 SHORT $LN244@Resize

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000f1	8b c2		 mov	 eax, edx
$LN247@Resize:

; 207  : 	::operator delete(_Ptr, _Bytes);

  000f3	51		 push	 ecx
  000f4	50		 push	 eax
  000f5	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  000fa	83 c4 08	 add	 esp, 8
$LN248@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  000fd	8d 04 b3	 lea	 eax, DWORD PTR [ebx+esi*4]
  00100	89 1f		 mov	 DWORD PTR [edi], ebx
  00102	89 47 04	 mov	 DWORD PTR [edi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00105	8b 44 24 14	 mov	 eax, DWORD PTR tv951[esp+12]
  00109	03 c3		 add	 eax, ebx
  0010b	89 47 08	 mov	 DWORD PTR [edi+8], eax
  0010e	5f		 pop	 edi

; 1472 : 		}

  0010f	5e		 pop	 esi
  00110	5d		 pop	 ebp
  00111	5b		 pop	 ebx
  00112	c2 08 00	 ret	 8
$LN2@Resize:

; 1443 : 			pointer _Appended_last = _Appended_first;
; 1444 : 
; 1445 : 			_TRY_BEGIN
; 1446 : 			_Appended_last = _Udefault_or_fill(_Appended_first, _Newsize - _Oldsize);
; 1447 : 			_Umove_if_noexcept(this->_Myfirst(), this->_Mylast(), _Newvec);
; 1448 : 			_CATCH_ALL
; 1449 : 			_Destroy(_Appended_first, _Appended_last);
; 1450 : 			this->_Getal().deallocate(_Newvec, _Newcapacity);
; 1451 : 			_RERAISE;
; 1452 : 			_CATCH_END
; 1453 : 
; 1454 : 			_Change_array(_Newvec, _Newsize, _Newcapacity);
; 1455 : 			}
; 1456 : 		else if (_Newsize > _Oldsize)

  00115	3b f5		 cmp	 esi, ebp
  00117	76 1e		 jbe	 SHORT $LN6@Resize
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00119	2b f5		 sub	 esi, ebp
  0011b	c1 e6 02	 shl	 esi, 2

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0011e	56		 push	 esi
  0011f	6a 00		 push	 0
  00121	53		 push	 ebx
  00122	e8 00 00 00 00	 call	 _memset
  00127	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0012a	8d 04 1e	 lea	 eax, DWORD PTR [esi+ebx]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1472 : 		}

  0012d	89 47 04	 mov	 DWORD PTR [edi+4], eax
  00130	5f		 pop	 edi
  00131	5e		 pop	 esi
  00132	5d		 pop	 ebp
  00133	5b		 pop	 ebx
  00134	c2 08 00	 ret	 8
$LN6@Resize:

; 1457 : 			{	// append
; 1458 : 			const pointer _Oldlast = this->_Mylast();
; 1459 : 			this->_Mylast() = _Udefault_or_fill(_Oldlast, _Newsize - _Oldsize);
; 1460 : 			_Orphan_range(_Oldlast, _Oldlast);
; 1461 : 			}
; 1462 : 		else if (_Newsize == _Oldsize)

  00137	74 06		 je	 SHORT $LN9@Resize

; 1463 : 			{	// nothing to do, avoid invalidating iterators
; 1464 : 			}
; 1465 : 		else
; 1466 : 			{	// trim
; 1467 : 			const pointer _Newlast = this->_Myfirst() + _Newsize;

  00139	8d 04 b0	 lea	 eax, DWORD PTR [eax+esi*4]

; 1472 : 		}

  0013c	89 47 04	 mov	 DWORD PTR [edi+4], eax
$LN9@Resize:
  0013f	5f		 pop	 edi
  00140	5e		 pop	 esi
  00141	5d		 pop	 ebp
  00142	5b		 pop	 ebx
  00143	c2 08 00	 ret	 8
$LN337@Resize:

; 1435 : 				{
; 1436 : 				_Xlength();

  00146	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN244@Resize:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0014b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN334@Resize:
  00150	cc		 int	 3
??$_Resize@V<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIV<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@Z ENDP ; std::vector<int,std::allocator<int> >::_Resize<<lambda_4f2fd6a84b983411848f0e0333d0ea32> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??0<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@QAE@QAV?$vector@HV?$allocator@H@std@@@std@@@Z
_TEXT	SEGMENT
__This$ = 8						; size = 4
??0<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@QAE@QAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; <lambda_4f2fd6a84b983411848f0e0333d0ea32>::<lambda_4f2fd6a84b983411848f0e0333d0ea32>, COMDAT
; _this$ = ecx

; 1480 : 			};

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __This$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax
  00006	8b c1		 mov	 eax, ecx
  00008	c2 04 00	 ret	 4
??0<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@QAE@QAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; <lambda_4f2fd6a84b983411848f0e0333d0ea32>::<lambda_4f2fd6a84b983411848f0e0333d0ea32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??R<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@QBEPAHPAHI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??R<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@QBEPAHPAHI@Z PROC ; <lambda_4f2fd6a84b983411848f0e0333d0ea32>::operator(), COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1478 : 			{

  00004	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00005	8b 74 24 08	 mov	 esi, DWORD PTR __Dest$[esp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1478 : 			{

  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000a	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	57		 push	 edi
  00012	6a 00		 push	 0
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001d	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1479 : 			return (_Udefault(_Dest, _Count));

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1480 : 			};

  00022	c2 08 00	 ret	 8
??R<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@QBEPAHPAHI@Z ENDP ; <lambda_4f2fd6a84b983411848f0e0333d0ea32>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 330  : 	return (__builtin_addressof(_Val));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Val$[esp-4]

; 331  : 	}

  00004	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\color.hpp
;	COMDAT ??0Color@core@@QAE@ABV01@@Z
_TEXT	SEGMENT
_t_color$ = 8						; size = 4
??0Color@core@@QAE@ABV01@@Z PROC			; core::Color::Color, COMDAT
; _this$ = ecx

; 20   :         {
; 21   :             *this = t_color;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _t_color$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	89 01		 mov	 DWORD PTR [ecx], eax

; 22   :         }

  00008	8b c1		 mov	 eax, ecx
  0000a	c2 04 00	 ret	 4
??0Color@core@@QAE@ABV01@@Z ENDP			; core::Color::Color
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?GetCellValue@Board@gameplay@core@@QBEHHH@Z
_TEXT	SEGMENT
_t_row$ = 8						; size = 4
_t_col$ = 12						; size = 4
?GetCellValue@Board@gameplay@core@@QBEHHH@Z PROC	; core::gameplay::Board::GetCellValue, COMDAT
; _this$ = ecx

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00000	53		 push	 ebx
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _t_row$[esp]
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00009	8b 7c 24 14	 mov	 edi, DWORD PTR _t_col$[esp+8]
  0000d	85 db		 test	 ebx, ebx
  0000f	78 10		 js	 SHORT $LN5@GetCellVal
  00011	3b 5e 14	 cmp	 ebx, DWORD PTR [esi+20]
  00014	7d 0b		 jge	 SHORT $LN5@GetCellVal
  00016	85 ff		 test	 edi, edi
  00018	78 07		 js	 SHORT $LN5@GetCellVal
  0001a	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0001d	3b f9		 cmp	 edi, ecx
  0001f	7c 17		 jl	 SHORT $LN6@GetCellVal
$LN5@GetCellVal:
  00021	6a 52		 push	 82			; 00000052H
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0002d	e8 00 00 00 00	 call	 __wassert
  00032	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@GetCellVal:
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00038	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\dev\tetris\src\math\matrix.hpp

; 83   :                 return m_data[row * m_cols + col];

  0003b	0f af cb	 imul	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0003e	03 cf		 add	 ecx, edi
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00046	c2 08 00	 ret	 8
?GetCellValue@Board@gameplay@core@@QBEHHH@Z ENDP	; core::gameplay::Board::GetCellValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\dev\tetris\src\board.cpp
;	COMDAT ?ClearLines@Board@gameplay@core@@QAEXPAVStats@23@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_t_value$ = 8						; size = 4
_t_stats$ = 8						; size = 4
?ClearLines@Board@gameplay@core@@QAEXPAVStats@23@@Z PROC ; core::gameplay::Board::ClearLines, COMDAT
; _this$ = ecx

; 101  : {

  00000	51		 push	 ecx
  00001	8b d1		 mov	 edx, ecx
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	89 54 24 08	 mov	 DWORD PTR _this$1$[esp+12], edx

; 102  :     i32 srcRow = m_boardRows - 1;

  00009	8b 72 04	 mov	 esi, DWORD PTR [edx+4]
  0000c	83 c6 ff	 add	 esi, -1
  0000f	8b de		 mov	 ebx, esi

; 103  :     for (i32 destRow = m_boardRows - 1; destRow >= 0; --destRow)

  00011	78 4a		 js	 SHORT $LN3@ClearLines
  00013	55		 push	 ebp
  00014	8b 6c 24 14	 mov	 ebp, DWORD PTR _t_stats$[esp+12]
  00018	57		 push	 edi
  00019	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@ClearLines:

; 104  :     {
; 105  :         while (srcRow >= 0 && t_stats->GetLines()[srcRow])

  00020	85 f6		 test	 esi, esi
  00022	78 0b		 js	 SHORT $LN211@ClearLines
$LL5@ClearLines:
  00024	80 3c 2e 00	 cmp	 BYTE PTR [esi+ebp], 0
  00028	74 39		 je	 SHORT $LN6@ClearLines

; 106  :         {
; 107  :             --srcRow;

  0002a	83 ee 01	 sub	 esi, 1
  0002d	79 f5		 jns	 SHORT $LL5@ClearLines
$LN211@ClearLines:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  0002f	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 41   : 		: _Ptr(_Parg)

  00032	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
; File c:\dev\tetris\src\math\matrix.hpp

; 58   :                 std::fill(m_data.begin() + t_startIndex,

  00035	8d 54 24 18	 lea	 edx, DWORD PTR _t_value$[esp+16]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  00039	0f af c3	 imul	 eax, ebx
; File c:\dev\tetris\src\math\matrix.hpp

; 58   :                 std::fill(m_data.begin() + t_startIndex,

  0003c	52		 push	 edx
; File c:\dev\tetris\src\board.cpp

; 112  :             m_boardData.SetElements(0, destRow * m_boardCols, 0);

  0003d	c7 44 24 1c 00
	00 00 00	 mov	 DWORD PTR _t_value$[esp+20], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  00045	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
; File c:\dev\tetris\src\math\matrix.hpp

; 58   :                 std::fill(m_data.begin() + t_startIndex,

  00048	50		 push	 eax
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@ClearLines:
; File c:\dev\tetris\src\board.cpp

; 103  :     for (i32 destRow = m_boardRows - 1; destRow >= 0; --destRow)

  00052	83 eb 01	 sub	 ebx, 1
  00055	8b 54 24 10	 mov	 edx, DWORD PTR _this$1$[esp+20]
  00059	79 c5		 jns	 SHORT $LL4@ClearLines
  0005b	5f		 pop	 edi
  0005c	5d		 pop	 ebp
$LN3@ClearLines:
  0005d	5e		 pop	 esi

; 122  :         }
; 123  :     }
; 124  : }

  0005e	5b		 pop	 ebx
  0005f	59		 pop	 ecx
  00060	c2 04 00	 ret	 4
$LN6@ClearLines:

; 108  :         }
; 109  :         
; 110  :         if (srcRow < 0)

  00063	85 f6		 test	 esi, esi
  00065	78 c8		 js	 SHORT $LN211@ClearLines

; 113  :         }
; 114  :         else
; 115  :         {
; 116  :             if (srcRow != destRow)

  00067	3b f3		 cmp	 esi, ebx
  00069	74 28		 je	 SHORT $LN9@ClearLines

; 118  :                 m_boardData.CopyElements(destRow * m_boardCols, srcRow * m_boardCols, m_boardCols);

  0006b	8b 7a 08	 mov	 edi, DWORD PTR [edx+8]
  0006e	8b c7		 mov	 eax, edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 41   : 		: _Ptr(_Parg)

  00070	8b 52 1c	 mov	 edx, DWORD PTR [edx+28]
; File c:\dev\tetris\src\board.cpp

; 118  :                 m_boardData.CopyElements(destRow * m_boardCols, srcRow * m_boardCols, m_boardCols);

  00073	0f af c6	 imul	 eax, esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  00076	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
; File c:\dev\tetris\src\board.cpp

; 118  :                 m_boardData.CopyElements(destRow * m_boardCols, srcRow * m_boardCols, m_boardCols);

  00079	03 c7		 add	 eax, edi
  0007b	c1 e0 02	 shl	 eax, 2
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  0007e	0f af fb	 imul	 edi, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00081	2b c1		 sub	 eax, ecx
; File c:\dev\tetris\src\board.cpp

; 118  :                 m_boardData.CopyElements(destRow * m_boardCols, srcRow * m_boardCols, m_boardCols);

  00083	03 c2		 add	 eax, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00085	50		 push	 eax
  00086	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  00087	8d 04 ba	 lea	 eax, DWORD PTR [edx+edi*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 _memmove
  00090	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN9@ClearLines:
; File c:\dev\tetris\src\board.cpp

; 121  :             --srcRow;

  00093	4e		 dec	 esi
  00094	eb bc		 jmp	 SHORT $LN2@ClearLines
?ClearLines@Board@gameplay@core@@QAEXPAVStats@23@@Z ENDP ; core::gameplay::Board::ClearLines
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\stats.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\stats.hpp
; File c:\dev\tetris\src\board.cpp
;	COMDAT ?FindLines@Board@gameplay@core@@QAEXPAVStats@23@@Z
_TEXT	SEGMENT
_t_stats$ = 8						; size = 4
?FindLines@Board@gameplay@core@@QAEXPAVStats@23@@Z PROC	; core::gameplay::Board::FindLines, COMDAT
; _this$ = ecx

; 85   : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 86   :     i32 count = 0;
; 87   :     for (i32 row = 0; row < m_boardRows; ++row)

  00005	33 db		 xor	 ebx, ebx
  00007	33 ed		 xor	 ebp, ebp
  00009	39 5f 04	 cmp	 DWORD PTR [edi+4], ebx
  0000c	7e 6f		 jle	 SHORT $LN43@FindLines
  0000e	56		 push	 esi
  0000f	90		 npad	 1
$LL4@FindLines:

; 60   :     for (i32 col = 0; col < m_boardCols; ++col)

  00010	33 f6		 xor	 esi, esi
  00012	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  00015	7e 3f		 jle	 SHORT $LN41@FindLines
$LL10@FindLines:
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00017	85 db		 test	 ebx, ebx
  00019	78 10		 js	 SHORT $LN17@FindLines
  0001b	3b 5f 14	 cmp	 ebx, DWORD PTR [edi+20]
  0001e	7d 0b		 jge	 SHORT $LN17@FindLines
  00020	85 f6		 test	 esi, esi
  00022	78 07		 js	 SHORT $LN17@FindLines
  00024	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00027	3b f0		 cmp	 esi, eax
  00029	7c 17		 jl	 SHORT $LN42@FindLines
$LN17@FindLines:
  0002b	6a 52		 push	 82			; 00000052H
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00037	e8 00 00 00 00	 call	 __wassert
  0003c	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0003f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN42@FindLines:
; File c:\dev\tetris\src\board.cpp

; 62   :         if (!GetCellValue(t_row, col))

  00042	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  00045	0f af c3	 imul	 eax, ebx
  00048	03 c6		 add	 eax, esi
; File c:\dev\tetris\src\board.cpp

; 62   :         if (!GetCellValue(t_row, col))

  0004a	83 3c 81 00	 cmp	 DWORD PTR [ecx+eax*4], 0
  0004e	74 29		 je	 SHORT $LN33@FindLines

; 60   :     for (i32 col = 0; col < m_boardCols; ++col)

  00050	46		 inc	 esi
  00051	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  00054	7c c1		 jl	 SHORT $LL10@FindLines
$LN41@FindLines:

; 65   :         }
; 66   :     }
; 67   :     
; 68   :     return true;

  00056	b1 01		 mov	 cl, 1
$LN7@FindLines:

; 88   :     {
; 89   :         bool isFilled = IsRowFilled(row);
; 90   :         t_stats->GetLines()[row] = isFilled;

  00058	8b 54 24 14	 mov	 edx, DWORD PTR _t_stats$[esp+12]
  0005c	8d 45 01	 lea	 eax, DWORD PTR [ebp+1]
  0005f	84 c9		 test	 cl, cl
  00061	0f 44 c5	 cmove	 eax, ebp
  00064	88 0c 13	 mov	 BYTE PTR [ebx+edx], cl
  00067	8b e8		 mov	 ebp, eax
  00069	43		 inc	 ebx
  0006a	3b 5f 04	 cmp	 ebx, DWORD PTR [edi+4]
  0006d	7c a1		 jl	 SHORT $LL4@FindLines
; File c:\dev\tetris\src\stats.hpp

; 38   :             inline void SetPendingLineCount(i32 t_pendingLineCount) { m_pendingLineCount = t_pendingLineCount; }

  0006f	5e		 pop	 esi
  00070	5f		 pop	 edi
  00071	89 6a 18	 mov	 DWORD PTR [edx+24], ebp
; File c:\dev\tetris\src\board.cpp

; 98   : }

  00074	5d		 pop	 ebp
  00075	5b		 pop	 ebx
  00076	c2 04 00	 ret	 4
$LN33@FindLines:

; 64   :             return false;

  00079	32 c9		 xor	 cl, cl
  0007b	eb db		 jmp	 SHORT $LN7@FindLines
$LN43@FindLines:
; File c:\dev\tetris\src\stats.hpp

; 38   :             inline void SetPendingLineCount(i32 t_pendingLineCount) { m_pendingLineCount = t_pendingLineCount; }

  0007d	8b 44 24 10	 mov	 eax, DWORD PTR _t_stats$[esp+8]
  00081	5f		 pop	 edi
  00082	89 68 18	 mov	 DWORD PTR [eax+24], ebp
; File c:\dev\tetris\src\board.cpp

; 98   : }

  00085	5d		 pop	 ebp
  00086	5b		 pop	 ebx
  00087	c2 04 00	 ret	 4
?FindLines@Board@gameplay@core@@QAEXPAVStats@23@@Z ENDP	; core::gameplay::Board::FindLines
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
;	COMDAT ?IsRowEmpty@Board@gameplay@core@@QAE_NH@Z
_TEXT	SEGMENT
_t_row$ = 8						; size = 4
?IsRowEmpty@Board@gameplay@core@@QAE_NH@Z PROC		; core::gameplay::Board::IsRowEmpty, COMDAT
; _this$ = ecx

; 72   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 73   :     for (i32 col = 0; col < m_boardCols; ++col)

  00005	33 f6		 xor	 esi, esi
  00007	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000a	7e 43		 jle	 SHORT $LN3@IsRowEmpty
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  0000c	8b 5c 24 10	 mov	 ebx, DWORD PTR _t_row$[esp+8]
$LL4@IsRowEmpty:
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00010	85 db		 test	 ebx, ebx
  00012	78 10		 js	 SHORT $LN11@IsRowEmpty
  00014	3b 5f 14	 cmp	 ebx, DWORD PTR [edi+20]
  00017	7d 0b		 jge	 SHORT $LN11@IsRowEmpty
  00019	85 f6		 test	 esi, esi
  0001b	78 07		 js	 SHORT $LN11@IsRowEmpty
  0001d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00020	3b f1		 cmp	 esi, ecx
  00022	7c 17		 jl	 SHORT $LN26@IsRowEmpty
$LN11@IsRowEmpty:
  00024	6a 52		 push	 82			; 00000052H
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00030	e8 00 00 00 00	 call	 __wassert
  00035	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@IsRowEmpty:
; File c:\dev\tetris\src\board.cpp

; 75   :         if (GetCellValue(t_row, col))

  0003b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0003e	0f af cb	 imul	 ecx, ebx
  00041	03 ce		 add	 ecx, esi
; File c:\dev\tetris\src\board.cpp

; 75   :         if (GetCellValue(t_row, col))

  00043	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00047	75 0e		 jne	 SHORT $LN22@IsRowEmpty

; 73   :     for (i32 col = 0; col < m_boardCols; ++col)

  00049	46		 inc	 esi
  0004a	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  0004d	7c c1		 jl	 SHORT $LL4@IsRowEmpty
$LN3@IsRowEmpty:
  0004f	5f		 pop	 edi

; 76   :         {
; 77   :             return false;
; 78   :         }
; 79   :     }
; 80   :     
; 81   :     return true;
; 82   : }

  00050	5e		 pop	 esi
  00051	b0 01		 mov	 al, 1
  00053	5b		 pop	 ebx
  00054	c2 04 00	 ret	 4
$LN22@IsRowEmpty:
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	32 c0		 xor	 al, al
  0005b	5b		 pop	 ebx
  0005c	c2 04 00	 ret	 4
?IsRowEmpty@Board@gameplay@core@@QAE_NH@Z ENDP		; core::gameplay::Board::IsRowEmpty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
;	COMDAT ?IsRowFilled@Board@gameplay@core@@QAE_NH@Z
_TEXT	SEGMENT
_t_row$ = 8						; size = 4
?IsRowFilled@Board@gameplay@core@@QAE_NH@Z PROC		; core::gameplay::Board::IsRowFilled, COMDAT
; _this$ = ecx

; 59   : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b f9		 mov	 edi, ecx

; 60   :     for (i32 col = 0; col < m_boardCols; ++col)

  00005	33 f6		 xor	 esi, esi
  00007	39 77 08	 cmp	 DWORD PTR [edi+8], esi
  0000a	7e 43		 jle	 SHORT $LN3@IsRowFille
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  0000c	8b 5c 24 10	 mov	 ebx, DWORD PTR _t_row$[esp+8]
$LL4@IsRowFille:
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00010	85 db		 test	 ebx, ebx
  00012	78 10		 js	 SHORT $LN11@IsRowFille
  00014	3b 5f 14	 cmp	 ebx, DWORD PTR [edi+20]
  00017	7d 0b		 jge	 SHORT $LN11@IsRowFille
  00019	85 f6		 test	 esi, esi
  0001b	78 07		 js	 SHORT $LN11@IsRowFille
  0001d	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00020	3b f1		 cmp	 esi, ecx
  00022	7c 17		 jl	 SHORT $LN26@IsRowFille
$LN11@IsRowFille:
  00024	6a 52		 push	 82			; 00000052H
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00030	e8 00 00 00 00	 call	 __wassert
  00035	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  00038	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN26@IsRowFille:
; File c:\dev\tetris\src\board.cpp

; 62   :         if (!GetCellValue(t_row, col))

  0003b	8b 47 1c	 mov	 eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0003e	0f af cb	 imul	 ecx, ebx
  00041	03 ce		 add	 ecx, esi
; File c:\dev\tetris\src\board.cpp

; 62   :         if (!GetCellValue(t_row, col))

  00043	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  00047	74 0e		 je	 SHORT $LN22@IsRowFille

; 60   :     for (i32 col = 0; col < m_boardCols; ++col)

  00049	46		 inc	 esi
  0004a	3b 77 08	 cmp	 esi, DWORD PTR [edi+8]
  0004d	7c c1		 jl	 SHORT $LL4@IsRowFille
$LN3@IsRowFille:
  0004f	5f		 pop	 edi

; 63   :         {
; 64   :             return false;
; 65   :         }
; 66   :     }
; 67   :     
; 68   :     return true;
; 69   : }

  00050	5e		 pop	 esi
  00051	b0 01		 mov	 al, 1
  00053	5b		 pop	 ebx
  00054	c2 04 00	 ret	 4
$LN22@IsRowFille:
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	32 c0		 xor	 al, al
  0005b	5b		 pop	 ebx
  0005c	c2 04 00	 ret	 4
?IsRowFilled@Board@gameplay@core@@QAE_NH@Z ENDP		; core::gameplay::Board::IsRowFilled
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
;	COMDAT ?DrawBoard@Board@gameplay@core@@QAEXHH@Z
_TEXT	SEGMENT
_this$1$ = -16						; size = 4
_y$1$ = -12						; size = 4
_col$1$ = -8						; size = 4
_row$1$ = -4						; size = 4
_t_xOffset$ = 8						; size = 4
_t_yOffset$ = 12					; size = 4
?DrawBoard@Board@gameplay@core@@QAEXHH@Z PROC		; core::gameplay::Board::DrawBoard, COMDAT
; _this$ = ecx

; 42   : {

  00000	83 ec 10	 sub	 esp, 16			; 00000010H
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR ?s_base@Palette@core@@2QBVColor@2@B
; File c:\dev\tetris\src\board.cpp

; 42   : {

  00008	53		 push	 ebx
  00009	55		 push	 ebp
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 43   :     Graphics::Instance()->DrawFillRect(t_xOffset, t_yOffset, m_boardCols * m_boardGridSize, m_boardRows * m_boardGridSize, Palette::s_base[0]);

  0000c	51		 push	 ecx
  0000d	8b d4		 mov	 edx, esp
  0000f	8b e9		 mov	 ebp, ecx
  00011	89 6c 24 14	 mov	 DWORD PTR _this$1$[esp+36], ebp
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  00015	89 02		 mov	 DWORD PTR [edx], eax
; File c:\dev\tetris\src\board.cpp

; 43   :     Graphics::Instance()->DrawFillRect(t_xOffset, t_yOffset, m_boardCols * m_boardGridSize, m_boardRows * m_boardGridSize, Palette::s_base[0]);

  00017	8b 45 04	 mov	 eax, DWORD PTR [ebp+4]
  0001a	0f af 45 10	 imul	 eax, DWORD PTR [ebp+16]
  0001e	50		 push	 eax
  0001f	8b 45 08	 mov	 eax, DWORD PTR [ebp+8]
  00022	0f af 45 10	 imul	 eax, DWORD PTR [ebp+16]
  00026	50		 push	 eax
  00027	ff 74 24 34	 push	 DWORD PTR _t_yOffset$[esp+40]
  0002b	ff 74 24 34	 push	 DWORD PTR _t_xOffset$[esp+44]
  0002f	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawFillRect

; 44   :     
; 45   :     for (i32 row = 0; row < m_boardRows; ++row)

  0003b	33 f6		 xor	 esi, esi
  0003d	89 74 24 1c	 mov	 DWORD PTR _row$1$[esp+32], esi
  00041	39 75 04	 cmp	 DWORD PTR [ebp+4], esi
  00044	0f 8e 25 01 00
	00		 jle	 $LN3@DrawBoard
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL4@DrawBoard:

; 46   :     {
; 47   :         for (i32 col = 0; col < m_boardCols; ++col)

  00050	33 db		 xor	 ebx, ebx
  00052	89 5c 24 18	 mov	 DWORD PTR _col$1$[esp+32], ebx
  00056	39 5d 08	 cmp	 DWORD PTR [ebp+8], ebx
  00059	0f 8e 02 01 00
	00		 jle	 $LN2@DrawBoard
  0005f	90		 npad	 1
$LL7@DrawBoard:
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00060	85 f6		 test	 esi, esi
  00062	78 10		 js	 SHORT $LN16@DrawBoard
  00064	3b 75 14	 cmp	 esi, DWORD PTR [ebp+20]
  00067	7d 0b		 jge	 SHORT $LN16@DrawBoard
  00069	85 db		 test	 ebx, ebx
  0006b	78 07		 js	 SHORT $LN16@DrawBoard
  0006d	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00070	3b d8		 cmp	 ebx, eax
  00072	7c 17		 jl	 SHORT $LN54@DrawBoard
$LN16@DrawBoard:
  00074	6a 52		 push	 82			; 00000052H
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00080	e8 00 00 00 00	 call	 __wassert
  00085	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00088	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN54@DrawBoard:
; File c:\dev\tetris\src\board.cpp

; 49   :             i32 value = GetCellValue(row, col);

  0008b	8b 4d 1c	 mov	 ecx, DWORD PTR [ebp+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0008e	0f af c6	 imul	 eax, esi
  00091	03 c3		 add	 eax, ebx
; File c:\dev\tetris\src\board.cpp

; 49   :             i32 value = GetCellValue(row, col);

  00093	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]

; 50   :             if (value)

  00096	85 c9		 test	 ecx, ecx
  00098	0f 84 b5 00 00
	00		 je	 $LN5@DrawBoard

; 24   :     i32 edgeSize = m_boardGridSize / 8;

  0009e	8b 5d 10	 mov	 ebx, DWORD PTR [ebp+16]
  000a1	8b c3		 mov	 eax, ebx
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  000a3	8b 3c 8d 00 00
	00 00		 mov	 edi, DWORD PTR ?s_base@Palette@core@@2QBVColor@2@B[ecx*4]
  000aa	8b 34 8d 00 00
	00 00		 mov	 esi, DWORD PTR ?s_light@Palette@core@@2QBVColor@2@B[ecx*4]
  000b1	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?s_dark@Palette@core@@2QBVColor@2@B[ecx*4]
; File c:\dev\tetris\src\board.cpp

; 24   :     i32 edgeSize = m_boardGridSize / 8;

  000b8	99		 cdq
  000b9	83 e2 07	 and	 edx, 7
  000bc	89 5c 24 14	 mov	 DWORD PTR _y$1$[esp+32], ebx

; 35   :         Graphics::Instance()->DrawFillRect(x, y, m_boardGridSize, m_boardGridSize, darkColor);

  000c0	51		 push	 ecx
  000c1	8d 2c 02	 lea	 ebp, DWORD PTR [edx+eax]
  000c4	8b c4		 mov	 eax, esp
  000c6	8b d3		 mov	 edx, ebx
  000c8	c1 fd 03	 sar	 ebp, 3
  000cb	0f af 54 24 20	 imul	 edx, DWORD PTR _row$1$[esp+36]
  000d0	0f af 5c 24 1c	 imul	 ebx, DWORD PTR _col$1$[esp+36]
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  000d5	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\dev\tetris\src\board.cpp

; 35   :         Graphics::Instance()->DrawFillRect(x, y, m_boardGridSize, m_boardGridSize, darkColor);

  000d7	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$1$[esp+36]
  000db	03 54 24 2c	 add	 edx, DWORD PTR _t_yOffset$[esp+32]
  000df	03 5c 24 28	 add	 ebx, DWORD PTR _t_xOffset$[esp+32]
  000e3	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  000e6	50		 push	 eax
  000e7	50		 push	 eax
  000e8	52		 push	 edx
  000e9	53		 push	 ebx
  000ea	89 54 24 28	 mov	 DWORD PTR _y$1$[esp+52], edx
  000ee	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  000f3	8b c8		 mov	 ecx, eax
  000f5	e8 00 00 00 00	 call	 ?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawFillRect

; 36   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y, m_boardGridSize - edgeSize, m_boardGridSize - edgeSize, lightColor);

  000fa	51		 push	 ecx
  000fb	8b c4		 mov	 eax, esp
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  000fd	89 30		 mov	 DWORD PTR [eax], esi
; File c:\dev\tetris\src\board.cpp

; 36   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y, m_boardGridSize - edgeSize, m_boardGridSize - edgeSize, lightColor);

  000ff	8d 34 2b	 lea	 esi, DWORD PTR [ebx+ebp]
  00102	8b 44 24 14	 mov	 eax, DWORD PTR _this$1$[esp+36]
  00106	8b 5c 24 18	 mov	 ebx, DWORD PTR _y$1$[esp+36]
  0010a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0010d	2b c5		 sub	 eax, ebp
  0010f	50		 push	 eax
  00110	50		 push	 eax
  00111	53		 push	 ebx
  00112	56		 push	 esi
  00113	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 ?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawFillRect

; 37   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y + edgeSize, m_boardGridSize - edgeSize * 2, m_boardGridSize - edgeSize * 2, baseColor);

  0011f	51		 push	 ecx
  00120	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$1$[esp+36]
  00124	8b c4		 mov	 eax, esp
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  00126	89 38		 mov	 DWORD PTR [eax], edi
; File c:\dev\tetris\src\board.cpp

; 37   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y + edgeSize, m_boardGridSize - edgeSize * 2, m_boardGridSize - edgeSize * 2, baseColor);

  00128	8d 04 6d 00 00
	00 00		 lea	 eax, DWORD PTR [ebp*2]
  0012f	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00132	2b c8		 sub	 ecx, eax
  00134	8d 04 2b	 lea	 eax, DWORD PTR [ebx+ebp]
  00137	51		 push	 ecx
  00138	51		 push	 ecx
  00139	50		 push	 eax
  0013a	56		 push	 esi
  0013b	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  00140	8b c8		 mov	 ecx, eax
  00142	e8 00 00 00 00	 call	 ?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawFillRect
  00147	8b 5c 24 18	 mov	 ebx, DWORD PTR _col$1$[esp+32]
  0014b	8b 6c 24 10	 mov	 ebp, DWORD PTR _this$1$[esp+32]
  0014f	8b 74 24 1c	 mov	 esi, DWORD PTR _row$1$[esp+32]
$LN5@DrawBoard:

; 46   :     {
; 47   :         for (i32 col = 0; col < m_boardCols; ++col)

  00153	43		 inc	 ebx
  00154	89 5c 24 18	 mov	 DWORD PTR _col$1$[esp+32], ebx
  00158	3b 5d 08	 cmp	 ebx, DWORD PTR [ebp+8]
  0015b	0f 8c ff fe ff
	ff		 jl	 $LL7@DrawBoard
$LN2@DrawBoard:

; 44   :     
; 45   :     for (i32 row = 0; row < m_boardRows; ++row)

  00161	46		 inc	 esi
  00162	89 74 24 1c	 mov	 DWORD PTR _row$1$[esp+32], esi
  00166	3b 75 04	 cmp	 esi, DWORD PTR [ebp+4]
  00169	0f 8c e1 fe ff
	ff		 jl	 $LL4@DrawBoard
$LN3@DrawBoard:

; 51   :             {
; 52   :                 DrawCell(row, col, value, t_xOffset, t_yOffset);
; 53   :             }
; 54   :         }
; 55   :     }
; 56   : }

  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5d		 pop	 ebp
  00172	5b		 pop	 ebx
  00173	83 c4 10	 add	 esp, 16			; 00000010H
  00176	c2 08 00	 ret	 8
?DrawBoard@Board@gameplay@core@@QAEXHH@Z ENDP		; core::gameplay::Board::DrawBoard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\color.hpp
; File c:\dev\tetris\src\board.cpp
;	COMDAT ?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_t_row$ = 8						; size = 4
_t_col$ = 12						; size = 4
_edgeSize$1$ = 16					; size = 4
_t_value$ = 16						; size = 4
_t_xOffset$ = 20					; size = 4
_t_yOffset$ = 24					; size = 4
_t_outline$ = 28					; size = 1
?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z PROC	; core::gameplay::Board::DrawCell, COMDAT
; _this$ = ecx

; 19   : {

  00000	51		 push	 ecx
  00001	8b c1		 mov	 eax, ecx

; 20   :     Color baseColor = Palette::s_base[t_value];

  00003	8b 4c 24 10	 mov	 ecx, DWORD PTR _t_value$[esp]
  00007	53		 push	 ebx
  00008	55		 push	 ebp
  00009	89 44 24 08	 mov	 DWORD PTR _this$1$[esp+12], eax

; 21   :     Color lightColor = Palette::s_light[t_value];
; 22   :     Color darkColor = Palette::s_dark[t_value];
; 23   :     
; 24   :     i32 edgeSize = m_boardGridSize / 8;

  0000d	8b 58 10	 mov	 ebx, DWORD PTR [eax+16]
  00010	8b c3		 mov	 eax, ebx
  00012	99		 cdq

; 26   :     i32 x = t_col * m_boardGridSize + t_xOffset;

  00013	8b eb		 mov	 ebp, ebx
  00015	0f af 6c 24 14	 imul	 ebp, DWORD PTR _t_col$[esp+8]
  0001a	83 e2 07	 and	 edx, 7

; 27   :     i32 y = t_row * m_boardGridSize + t_yOffset;

  0001d	0f af 5c 24 10	 imul	 ebx, DWORD PTR _t_row$[esp+8]
  00022	03 c2		 add	 eax, edx
  00024	56		 push	 esi
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  00025	8b 34 8d 00 00
	00 00		 mov	 esi, DWORD PTR ?s_base@Palette@core@@2QBVColor@2@B[ecx*4]
; File c:\dev\tetris\src\board.cpp

; 19   : {

  0002c	57		 push	 edi
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  0002d	8b 3c 8d 00 00
	00 00		 mov	 edi, DWORD PTR ?s_light@Palette@core@@2QBVColor@2@B[ecx*4]
  00034	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?s_dark@Palette@core@@2QBVColor@2@B[ecx*4]
; File c:\dev\tetris\src\board.cpp

; 26   :     i32 x = t_col * m_boardGridSize + t_xOffset;

  0003b	03 6c 24 24	 add	 ebp, DWORD PTR _t_xOffset$[esp+16]

; 27   :     i32 y = t_row * m_boardGridSize + t_yOffset;

  0003f	03 5c 24 28	 add	 ebx, DWORD PTR _t_yOffset$[esp+16]
  00043	c1 f8 03	 sar	 eax, 3

; 28   :     
; 29   :     if (t_outline)

  00046	80 7c 24 2c 00	 cmp	 BYTE PTR _t_outline$[esp+16], 0
  0004b	51		 push	 ecx
  0004c	89 44 24 24	 mov	 DWORD PTR _edgeSize$1$[esp+20], eax
  00050	8b c4		 mov	 eax, esp
  00052	74 21		 je	 SHORT $LN2@DrawCell

; 31   :         Graphics::Instance()->DrawRect(x, y, m_boardGridSize, m_boardGridSize, baseColor);

  00054	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$1$[esp+24]
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  00058	89 30		 mov	 DWORD PTR [eax], esi
; File c:\dev\tetris\src\board.cpp

; 31   :         Graphics::Instance()->DrawRect(x, y, m_boardGridSize, m_boardGridSize, baseColor);

  0005a	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0005d	50		 push	 eax
  0005e	50		 push	 eax
  0005f	53		 push	 ebx
  00060	55		 push	 ebp
  00061	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  00066	8b c8		 mov	 ecx, eax
  00068	e8 00 00 00 00	 call	 ?DrawRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawRect

; 38   :     }
; 39   : }

  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi
  0006f	5d		 pop	 ebp
  00070	5b		 pop	 ebx
  00071	59		 pop	 ecx
  00072	c2 18 00	 ret	 24			; 00000018H
$LN2@DrawCell:
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  00075	89 08		 mov	 DWORD PTR [eax], ecx
; File c:\dev\tetris\src\board.cpp

; 35   :         Graphics::Instance()->DrawFillRect(x, y, m_boardGridSize, m_boardGridSize, darkColor);

  00077	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$1$[esp+24]
  0007b	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  0007e	50		 push	 eax
  0007f	50		 push	 eax
  00080	53		 push	 ebx
  00081	55		 push	 ebp
  00082	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  00087	8b c8		 mov	 ecx, eax
  00089	e8 00 00 00 00	 call	 ?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawFillRect

; 36   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y, m_boardGridSize - edgeSize, m_boardGridSize - edgeSize, lightColor);

  0008e	51		 push	 ecx
  0008f	8b 4c 24 24	 mov	 ecx, DWORD PTR _edgeSize$1$[esp+20]
  00093	8b c4		 mov	 eax, esp
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  00095	89 38		 mov	 DWORD PTR [eax], edi
; File c:\dev\tetris\src\board.cpp

; 36   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y, m_boardGridSize - edgeSize, m_boardGridSize - edgeSize, lightColor);

  00097	8d 3c 29	 lea	 edi, DWORD PTR [ecx+ebp]
  0009a	8b 44 24 14	 mov	 eax, DWORD PTR _this$1$[esp+24]
  0009e	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  000a1	2b c1		 sub	 eax, ecx
  000a3	50		 push	 eax
  000a4	50		 push	 eax
  000a5	53		 push	 ebx
  000a6	57		 push	 edi
  000a7	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  000ac	8b c8		 mov	 ecx, eax
  000ae	e8 00 00 00 00	 call	 ?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawFillRect

; 37   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y + edgeSize, m_boardGridSize - edgeSize * 2, m_boardGridSize - edgeSize * 2, baseColor);

  000b3	8b 54 24 20	 mov	 edx, DWORD PTR _edgeSize$1$[esp+16]
  000b7	51		 push	 ecx
  000b8	8b 4c 24 14	 mov	 ecx, DWORD PTR _this$1$[esp+24]
  000bc	8b c4		 mov	 eax, esp
; File c:\dev\tetris\src\color.hpp

; 21   :             *this = t_color;

  000be	89 30		 mov	 DWORD PTR [eax], esi
; File c:\dev\tetris\src\board.cpp

; 37   :         Graphics::Instance()->DrawFillRect(x + edgeSize, y + edgeSize, m_boardGridSize - edgeSize * 2, m_boardGridSize - edgeSize * 2, baseColor);

  000c0	8d 04 12	 lea	 eax, DWORD PTR [edx+edx]
  000c3	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  000c6	2b c8		 sub	 ecx, eax
  000c8	8d 04 13	 lea	 eax, DWORD PTR [ebx+edx]
  000cb	51		 push	 ecx
  000cc	51		 push	 ecx
  000cd	50		 push	 eax
  000ce	57		 push	 edi
  000cf	e8 00 00 00 00	 call	 ?Instance@Graphics@graphics@core@@SAPAV123@XZ ; core::graphics::Graphics::Instance
  000d4	8b c8		 mov	 ecx, eax
  000d6	e8 00 00 00 00	 call	 ?DrawFillRect@Graphics@graphics@core@@QAEXHHHHVColor@3@@Z ; core::graphics::Graphics::DrawFillRect

; 38   :     }
; 39   : }

  000db	5f		 pop	 edi
  000dc	5e		 pop	 esi
  000dd	5d		 pop	 ebp
  000de	5b		 pop	 ebx
  000df	59		 pop	 ecx
  000e0	c2 18 00	 ret	 24			; 00000018H
?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z ENDP	; core::gameplay::Board::DrawCell
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.cpp
;	COMDAT ??0Board@gameplay@core@@QAE@HHHH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T2 = 8							; size = 4
_t_boardRows$ = 8					; size = 4
_t_boardCols$ = 12					; size = 4
_t_boardVisibleRows$ = 16				; size = 4
_t_boardGridSize$ = 20					; size = 4
??0Board@gameplay@core@@QAE@HHHH@Z PROC			; core::gameplay::Board::Board, COMDAT
; _this$ = ecx

; 10   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Board@gameplay@core@@QAE@HHHH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	8b f9		 mov	 edi, ecx
  00027	89 7d f0	 mov	 DWORD PTR _this$[ebp], edi
; File c:\dev\tetris\src\math\matrix.hpp

; 18   :             std::vector<i32> m_data = std::vector<i32>();

  0002a	8d 4f 1c	 lea	 ecx, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 389  : 		: _Myfirst(),

  0002d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 390  : 		_Mylast(),

  00033	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0003a	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
; File c:\dev\tetris\src\board.cpp

; 12   :     m_boardCols = t_boardCols;

  00041	8b 55 0c	 mov	 edx, DWORD PTR _t_boardCols$[ebp]

; 13   :     m_boardVisibleRows = t_boardVisibleRows;

  00044	8b 45 10	 mov	 eax, DWORD PTR _t_boardVisibleRows$[ebp]
  00047	8b 75 08	 mov	 esi, DWORD PTR _t_boardRows$[ebp]
  0004a	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 14   :     m_boardGridSize = t_boardGridSize;

  0004d	8b 45 14	 mov	 eax, DWORD PTR _t_boardGridSize$[ebp]
  00050	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00053	89 57 08	 mov	 DWORD PTR [edi+8], edx
  00056	89 47 10	 mov	 DWORD PTR [edi+16], eax
; File c:\dev\tetris\src\math\matrix.hpp

; 45   :                 m_rows = rows;

  00059	89 77 14	 mov	 DWORD PTR [edi+20], esi

; 47   :                 m_data.resize(rows * cols);

  0005c	0f af f2	 imul	 esi, edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  0005f	51		 push	 ecx
; File c:\dev\tetris\src\board.cpp

; 10   : {

  00060	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
; File c:\dev\tetris\src\math\matrix.hpp

; 46   :                 m_cols = cols;

  00067	89 57 18	 mov	 DWORD PTR [edi+24], edx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  0006a	56		 push	 esi
  0006b	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIV<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@Z ; std::vector<int,std::allocator<int> >::_Resize<<lambda_4f2fd6a84b983411848f0e0333d0ea32> >
; File c:\dev\tetris\src\math\matrix.hpp

; 53   :                 std::fill(m_data.begin(), m_data.end(), 0);

  00070	8d 45 08	 lea	 eax, DWORD PTR $T2[ebp]
  00073	c7 45 08 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0007a	50		 push	 eax
  0007b	ff 77 20	 push	 DWORD PTR [edi+32]
  0007e	ff 77 1c	 push	 DWORD PTR [edi+28]
  00081	e8 00 00 00 00	 call	 ??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\dev\tetris\src\board.cpp

; 16   : }

  00089	8b c7		 mov	 eax, edi
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00095	59		 pop	 ecx
  00096	5f		 pop	 edi
  00097	5e		 pop	 esi
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Board@gameplay@core@@QAE@HHHH@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 14	 add	 ecx, 20			; 00000014H
  00006	e9 00 00 00 00	 jmp	 ??1Matrix@math@core@@QAE@XZ
__ehhandler$??0Board@gameplay@core@@QAE@HHHH@Z:
  0000b	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000f	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00012	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Board@gameplay@core@@QAE@HHHH@Z
  00021	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Board@gameplay@core@@QAE@HHHH@Z ENDP			; core::gameplay::Board::Board
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\stats.hpp
;	COMDAT ?SetPendingLineCount@Stats@gameplay@core@@QAEXH@Z
_TEXT	SEGMENT
_t_pendingLineCount$ = 8				; size = 4
?SetPendingLineCount@Stats@gameplay@core@@QAEXH@Z PROC	; core::gameplay::Stats::SetPendingLineCount, COMDAT
; _this$ = ecx

; 38   :             inline void SetPendingLineCount(i32 t_pendingLineCount) { m_pendingLineCount = t_pendingLineCount; }

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _t_pendingLineCount$[esp-4]
  00004	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00007	c2 04 00	 ret	 4
?SetPendingLineCount@Stats@gameplay@core@@QAEXH@Z ENDP	; core::gameplay::Stats::SetPendingLineCount
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\stats.hpp
;	COMDAT ?GetLines@Stats@gameplay@core@@QAEPA_NXZ
_TEXT	SEGMENT
?GetLines@Stats@gameplay@core@@QAEPA_NXZ PROC		; core::gameplay::Stats::GetLines, COMDAT
; _this$ = ecx

; 31   :             inline bool* GetLines() { return m_lines; }

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
?GetLines@Stats@gameplay@core@@QAEPA_NXZ ENDP		; core::gameplay::Stats::GetLines
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
__Dest$ = 20						; size = 4
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@00@Z PROC ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __First$[esp-4]

; 2440 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00004	56		 push	 esi

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00005	8b 74 24 10	 mov	 esi, DWORD PTR __Last$[esp]

; 2440 : 	{	// copy [_First, _Last) to [_Dest, ...)

  00009	57		 push	 edi

; 2401 : 	char * const _Dest_ch = const_cast<char *>(reinterpret_cast<volatile char *>(_Dest));

  0000a	8b 7c 24 18	 mov	 edi, DWORD PTR __Dest$[esp+4]

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  0000e	2b f0		 sub	 esi, eax

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00010	56		 push	 esi
  00011	50		 push	 eax
  00012	57		 push	 edi
  00013	e8 00 00 00 00	 call	 _memmove

; 2441 : 	_Adl_verify_range(_First, _Last);
; 2442 : 	const auto _UFirst = _Get_unwrapped(_First);
; 2443 : 	const auto _ULast = _Get_unwrapped(_Last);
; 2444 : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 2445 : 	_Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
; 2446 : 	return (_Dest);

  00018	8b 44 24 18	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp+16]

; 2404 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

  0001c	8d 0c 3e	 lea	 ecx, DWORD PTR [esi+edi]
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2441 : 	_Adl_verify_range(_First, _Last);
; 2442 : 	const auto _UFirst = _Get_unwrapped(_First);
; 2443 : 	const auto _ULast = _Get_unwrapped(_Last);
; 2444 : 	const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
; 2445 : 	_Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
; 2446 : 	return (_Dest);

  00022	89 08		 mov	 DWORD PTR [eax], ecx
  00024	5f		 pop	 edi
  00025	5e		 pop	 esi

; 2447 : 	}

  00026	c3		 ret	 0
??$copy@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@V12@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@00@Z ENDP ; std::copy<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z PROC ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>, COMDAT

; 2923 : 	{	// copy _Val through [_First, _Last)

  00000	53		 push	 ebx

; 2917 : 	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR __First$[esp]

; 2924 : 	_Adl_verify_range(_First, _Last);
; 2925 : 	_Fill_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val);

  00005	33 c9		 xor	 ecx, ecx
  00007	55		 push	 ebp
  00008	8b 6c 24 10	 mov	 ebp, DWORD PTR __Last$[esp+4]
  0000c	33 d2		 xor	 edx, edx
  0000e	2b eb		 sub	 ebp, ebx
  00010	83 c5 03	 add	 ebp, 3
  00013	c1 ed 02	 shr	 ebp, 2
  00016	3b 5c 24 10	 cmp	 ebx, DWORD PTR __Last$[esp+4]
  0001a	0f 47 e9	 cmova	 ebp, ecx

; 2902 : 	for (; _First != _Last; ++_First)

  0001d	85 ed		 test	 ebp, ebp
  0001f	74 52		 je	 SHORT $LN21@fill
  00021	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  00025	57		 push	 edi
  00026	83 fd 04	 cmp	 ebp, 4
  00029	72 32		 jb	 SHORT $LN27@fill

; 2903 : 		*_First = _Val;

  0002b	8b 38		 mov	 edi, DWORD PTR [eax]

; 2924 : 	_Adl_verify_range(_First, _Last);
; 2925 : 	_Fill_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val);

  0002d	8d 4b fc	 lea	 ecx, DWORD PTR [ebx-4]
  00030	8d 0c a9	 lea	 ecx, DWORD PTR [ecx+ebp*4]
  00033	3b d8		 cmp	 ebx, eax
  00035	77 04		 ja	 SHORT $LN28@fill
  00037	3b c8		 cmp	 ecx, eax
  00039	73 22		 jae	 SHORT $LN27@fill
$LN28@fill:
  0003b	56		 push	 esi
  0003c	8b f5		 mov	 esi, ebp
  0003e	83 e6 fc	 and	 esi, -4			; fffffffcH
$LL22@fill:

; 2902 : 	for (; _First != _Last; ++_First)

  00041	83 c2 04	 add	 edx, 4
  00044	3b d6		 cmp	 edx, esi
  00046	75 f9		 jne	 SHORT $LL22@fill

; 2924 : 	_Adl_verify_range(_First, _Last);
; 2925 : 	_Fill_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val);

  00048	c1 e6 02	 shl	 esi, 2
  0004b	8b c7		 mov	 eax, edi
  0004d	8b ce		 mov	 ecx, esi
  0004f	8b fb		 mov	 edi, ebx
  00051	c1 e9 02	 shr	 ecx, 2
  00054	03 de		 add	 ebx, esi
  00056	f3 ab		 rep stosd
  00058	8b 44 24 1c	 mov	 eax, DWORD PTR __Val$[esp+12]
  0005c	5e		 pop	 esi
$LN27@fill:

; 2902 : 	for (; _First != _Last; ++_First)

  0005d	5f		 pop	 edi
  0005e	3b d5		 cmp	 edx, ebp
  00060	74 11		 je	 SHORT $LN21@fill
$LL26@fill:

; 2903 : 		*_First = _Val;

  00062	8b 00		 mov	 eax, DWORD PTR [eax]

; 2924 : 	_Adl_verify_range(_First, _Last);
; 2925 : 	_Fill_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val);

  00064	8d 5b 04	 lea	 ebx, DWORD PTR [ebx+4]

; 2902 : 	for (; _First != _Last; ++_First)

  00067	42		 inc	 edx

; 2903 : 		*_First = _Val;

  00068	89 43 fc	 mov	 DWORD PTR [ebx-4], eax
  0006b	8b 44 24 14	 mov	 eax, DWORD PTR __Val$[esp+4]
  0006f	3b d5		 cmp	 edx, ebp
  00071	75 ef		 jne	 SHORT $LL26@fill
$LN21@fill:
  00073	5d		 pop	 ebp

; 2926 : 	}

  00074	5b		 pop	 ebx
  00075	c3		 ret	 0
??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z ENDP ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ
_TEXT	SEGMENT
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 327  : 		return (this->_Ptr);

  00000	8b 01		 mov	 eax, DWORD PTR [ecx]

; 328  : 		}

  00002	c3		 ret	 0
?_Unwrapped@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+, COMDAT
; _this$ = ecx

; 130  : 		_Ptr += _Off;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]

; 300  : 		_Vector_iterator _Tmp = *this;
; 301  : 		return (_Tmp += _Off);

  00009	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 302  : 		}

  0000f	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=, COMDAT
; _this$ = ecx

; 130  : 		_Ptr += _Off;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	c1 e0 02	 shl	 eax, 2
  00007	01 01		 add	 DWORD PTR [ecx], eax

; 294  : 		*(_Mybase *)this += _Off;
; 295  : 		return (*this);

  00009	8b c1		 mov	 eax, ecx

; 296  : 		}

  0000b	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx

; 41   : 		: _Ptr(_Parg)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Parg$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 254  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEXPBH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEXPBH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Seek_to, COMDAT
; _this$ = ecx

; 219  : 		_Ptr = _Const_cast(_It);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __It$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 220  : 		}

  00006	c2 04 00	 ret	 4
?_Seek_to@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEXPBH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Seek_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=, COMDAT
; _this$ = ecx

; 129  : 		_Verify_offset(_Off);
; 130  : 		_Ptr += _Off;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Off$[esp-4]
  00004	c1 e0 02	 shl	 eax, 2
  00007	01 01		 add	 DWORD PTR [ecx], eax

; 131  : 		return (*this);

  00009	8b c1		 mov	 eax, ecx

; 132  : 		}

  0000b	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset, COMDAT
; _this$ = ecx

; 110  :  #if _ITERATOR_DEBUG_LEVEL == 0
; 111  : 		(void)_Off;
; 112  :  #else /* ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv */
; 113  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 114  : 		_STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 115  : 		if (_Off < 0)
; 116  : 			{
; 117  : 			_STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 118  : 			}
; 119  : 
; 120  : 		if (_Off > 0)
; 121  : 			{
; 122  : 			_STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 123  : 			}
; 124  :  #endif /* _ITERATOR_DEBUG_LEVEL == 0 */
; 125  : 		}

  00000	c2 04 00	 ret	 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx

; 41   : 		: _Ptr(_Parg)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Parg$[esp-4]
  00004	89 01		 mov	 DWORD PTR [ecx], eax

; 43   : 		this->_Adopt(_Pvector);
; 44   : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??1Matrix@math@core@@QAE@XZ
_TEXT	SEGMENT
??1Matrix@math@core@@QAE@XZ PROC			; core::math::Matrix::~Matrix, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1913 : 		if (this->_Myfirst() != pointer())

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx
  00003	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  00006	85 c0		 test	 eax, eax
  00008	74 41		 je	 SHORT $LN6@Matrix

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  0000a	8b 56 10	 mov	 edx, DWORD PTR [esi+16]
  0000d	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000f	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00012	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00018	72 12		 jb	 SHORT $LN82@Matrix

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  0001a	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001d	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00020	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00022	83 c0 fc	 add	 eax, -4			; fffffffcH
  00025	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00028	77 23		 ja	 SHORT $LN79@Matrix

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0002a	8b c1		 mov	 eax, ecx
$LN82@Matrix:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002c	52		 push	 edx
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00033	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 207  : 	::operator delete(_Ptr, _Bytes);

  0003a	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1919 : 			this->_Mylast() = pointer();

  0003d	c7 46 0c 00 00
	00 00		 mov	 DWORD PTR [esi+12], 0

; 1920 : 			this->_Myend() = pointer();

  00044	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
$LN6@Matrix:
  0004b	5e		 pop	 esi
  0004c	c3		 ret	 0
$LN79@Matrix:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004d	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN106@Matrix:
  00052	cc		 int	 3
??1Matrix@math@core@@QAE@XZ ENDP			; core::math::Matrix::~Matrix
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?GetValue@Matrix@math@core@@QBEHHH@Z
_TEXT	SEGMENT
_row$ = 8						; size = 4
_col$ = 12						; size = 4
?GetValue@Matrix@math@core@@QBEHHH@Z PROC		; core::math::Matrix::GetValue, COMDAT
; _this$ = ecx

; 81   :             {

  00000	53		 push	 ebx

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _col$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _row$[esp+8]
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 ff		 test	 edi, edi
  0000f	78 0f		 js	 SHORT $LN3@GetValue
  00011	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00013	7d 0b		 jge	 SHORT $LN3@GetValue
  00015	85 db		 test	 ebx, ebx
  00017	78 07		 js	 SHORT $LN3@GetValue
  00019	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001c	3b d9		 cmp	 ebx, ecx
  0001e	7c 17		 jl	 SHORT $LN4@GetValue
$LN3@GetValue:
  00020	6a 52		 push	 82			; 00000052H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0002c	e8 00 00 00 00	 call	 __wassert
  00031	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GetValue:

; 83   :                 return m_data[row * m_cols + col];

  00037	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003a	0f af cf	 imul	 ecx, edi
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0003f	03 cb		 add	 ecx, ebx
; File c:\dev\tetris\src\math\matrix.hpp

; 83   :                 return m_data[row * m_cols + col];

  00041	5b		 pop	 ebx
  00042	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 84   :             }

  00045	c2 08 00	 ret	 8
?GetValue@Matrix@math@core@@QBEHHH@Z ENDP		; core::math::Matrix::GetValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?CopyElements@Matrix@math@core@@QAEXHHH@Z
_TEXT	SEGMENT
_t_destIndex$ = 8					; size = 4
_t_srcIndex$ = 12					; size = 4
_t_length$ = 16						; size = 4
?CopyElements@Matrix@math@core@@QAEXHHH@Z PROC		; core::math::Matrix::CopyElements, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 41   : 		: _Ptr(_Parg)

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]

; 130  : 		_Ptr += _Off;

  00003	8b 54 24 08	 mov	 edx, DWORD PTR _t_srcIndex$[esp-4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00007	8b 4c 24 0c	 mov	 ecx, DWORD PTR _t_length$[esp-4]
  0000b	03 ca		 add	 ecx, edx
; File c:\dev\tetris\src\math\matrix.hpp

; 64   :             {

  0000d	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  0000e	8d 34 90	 lea	 esi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00011	c1 e1 02	 shl	 ecx, 2
  00014	2b ce		 sub	 ecx, esi
  00016	03 c8		 add	 ecx, eax
  00018	51		 push	 ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  00019	8b 4c 24 0c	 mov	 ecx, DWORD PTR _t_destIndex$[esp+4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0001d	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 130  : 		_Ptr += _Off;

  0001e	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 _memmove
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002a	5e		 pop	 esi
; File c:\dev\tetris\src\math\matrix.hpp

; 68   :             }

  0002b	c2 0c 00	 ret	 12			; 0000000cH
?CopyElements@Matrix@math@core@@QAEXHHH@Z ENDP		; core::math::Matrix::CopyElements
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?SetElements@Matrix@math@core@@QAEXHHH@Z
_TEXT	SEGMENT
_t_startIndex$ = 8					; size = 4
_t_endIndex$ = 12					; size = 4
_t_value$ = 16						; size = 4
?SetElements@Matrix@math@core@@QAEXHHH@Z PROC		; core::math::Matrix::SetElements, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 41   : 		: _Ptr(_Parg)

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 130  : 		_Ptr += _Off;

  00003	8b 44 24 08	 mov	 eax, DWORD PTR _t_endIndex$[esp-4]
  00007	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  0000a	8b 44 24 04	 mov	 eax, DWORD PTR _t_startIndex$[esp-4]
  0000e	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
; File c:\dev\tetris\src\math\matrix.hpp

; 58   :                 std::fill(m_data.begin() + t_startIndex,

  00011	8d 54 24 0c	 lea	 edx, DWORD PTR _t_value$[esp-4]
  00015	52		 push	 edx
  00016	51		 push	 ecx
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 59   :                           m_data.begin() + t_endIndex,
; 60   :                           t_value);
; 61   :             }

  00020	c2 0c 00	 ret	 12			; 0000000cH
?SetElements@Matrix@math@core@@QAEXHHH@Z ENDP		; core::math::Matrix::SetElements
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?Clear@Matrix@math@core@@QAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?Clear@Matrix@math@core@@QAEXXZ PROC			; core::math::Matrix::Clear, COMDAT
; _this$ = ecx

; 52   :             {

  00000	51		 push	 ecx

; 53   :                 std::fill(m_data.begin(), m_data.end(), 0);

  00001	8d 04 24	 lea	 eax, DWORD PTR $T1[esp+4]
  00004	c7 04 24 00 00
	00 00		 mov	 DWORD PTR $T1[esp+4], 0
  0000b	50		 push	 eax
  0000c	ff 71 0c	 push	 DWORD PTR [ecx+12]
  0000f	ff 71 08	 push	 DWORD PTR [ecx+8]
  00012	e8 00 00 00 00	 call	 ??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>

; 54   :             }

  00017	83 c4 10	 add	 esp, 16			; 00000010H
  0001a	c3		 ret	 0
?Clear@Matrix@math@core@@QAEXXZ ENDP			; core::math::Matrix::Clear
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?Resize@Matrix@math@core@@QAEXHH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_rows$ = 8						; size = 4
_cols$ = 12						; size = 4
?Resize@Matrix@math@core@@QAEXHH@Z PROC			; core::math::Matrix::Resize, COMDAT
; _this$ = ecx

; 45   :                 m_rows = rows;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _rows$[esp-4]

; 46   :                 m_cols = cols;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR _cols$[esp-4]
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f9		 mov	 edi, ecx
  0000c	89 17		 mov	 DWORD PTR [edi], edx

; 47   :                 m_data.resize(rows * cols);

  0000e	8d 77 08	 lea	 esi, DWORD PTR [edi+8]
  00011	0f af d0	 imul	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00014	8b ce		 mov	 ecx, esi
  00016	56		 push	 esi
; File c:\dev\tetris\src\math\matrix.hpp

; 46   :                 m_cols = cols;

  00017	89 47 04	 mov	 DWORD PTR [edi+4], eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1482 : 		_Resize(_Newsize, _Lambda_default);

  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIV<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@Z ; std::vector<int,std::allocator<int> >::_Resize<<lambda_4f2fd6a84b983411848f0e0333d0ea32> >
; File c:\dev\tetris\src\math\matrix.hpp

; 53   :                 std::fill(m_data.begin(), m_data.end(), 0);

  00020	8d 44 24 0c	 lea	 eax, DWORD PTR $T1[esp+4]
  00024	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR $T1[esp+4], 0
  0002c	50		 push	 eax
  0002d	ff 77 0c	 push	 DWORD PTR [edi+12]
  00030	ff 36		 push	 DWORD PTR [esi]
  00032	e8 00 00 00 00	 call	 ??$fill@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@H@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0ABH@Z ; std::fill<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,int>
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi

; 48   :                 Clear();
; 49   :             }

  0003c	c2 08 00	 ret	 8
?Resize@Matrix@math@core@@QAEXHH@Z ENDP			; core::math::Matrix::Resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ??0Matrix@math@core@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Matrix@math@core@@QAE@XZ PROC			; core::math::Matrix::Matrix, COMDAT
; _this$ = ecx

; 22   :             Matrix() {}

  00000	51		 push	 ecx
  00001	89 0c 24	 mov	 DWORD PTR _this$[esp+4], ecx
  00004	8b c1		 mov	 eax, ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 389  : 		: _Myfirst(),

  00006	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 390  : 		_Mylast(),

  0000d	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 391  : 		_Myend()

  00014	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
; File c:\dev\tetris\src\math\matrix.hpp

; 22   :             Matrix() {}

  0001b	59		 pop	 ecx
  0001c	c3		 ret	 0
??0Matrix@math@core@@QAE@XZ ENDP			; core::math::Matrix::Matrix
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1960 : 		}

  00000	c2 08 00	 ret	 8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1926 : 		_Xlength_error("vector<T> too long");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
  00005	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN3@Xlength:
  0000a	cc		 int	 3
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1910 : 		{	// free all storage

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1911 : 		this->_Orphan_all();
; 1912 : 
; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN2@Tidy

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Tidy

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN75@Tidy

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Tidy:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 207  : 	::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN2@Tidy:

; 1922 : 		}

  00049	5e		 pop	 esi
  0004a	c3		 ret	 0
$LN75@Tidy:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Tidy:
  00050	cc		 int	 3
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT
; _this$ = ecx

; 1895 : 		{	// orphan all iterators, discard old array, acquire new array

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1896 : 		this->_Orphan_all();
; 1897 : 
; 1898 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 2c		 je	 SHORT $LN79@Change_arr

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN78@Change_arr

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 2a		 ja	 SHORT $LN75@Change_arr

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN78@Change_arr:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
$LN79@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1904 : 		this->_Myfirst() = _Newvec;

  00035	8b 4c 24 08	 mov	 ecx, DWORD PTR __Newvec$[esp]

; 1905 : 		this->_Mylast() = _Newvec + _Newsize;

  00039	8b 44 24 0c	 mov	 eax, DWORD PTR __Newsize$[esp]
  0003d	89 0e		 mov	 DWORD PTR [esi], ecx
  0003f	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00042	89 46 04	 mov	 DWORD PTR [esi+4], eax

; 1906 : 		this->_Myend() = _Newvec + _Newcapacity;

  00045	8b 44 24 10	 mov	 eax, DWORD PTR __Newcapacity$[esp]
  00049	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0004c	89 46 08	 mov	 DWORD PTR [esi+8], eax
  0004f	5e		 pop	 esi

; 1907 : 		}

  00050	c2 0c 00	 ret	 12			; 0000000cH
$LN75@Change_arr:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00053	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN100@Change_arr:
  00058	cc		 int	 3
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  00003	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00008	2b 11		 sub	 edx, DWORD PTR [ecx]
  0000a	c1 fa 02	 sar	 edx, 2

; 1854 : 		const size_type _Oldcapacity = capacity();
; 1855 : 
; 1856 : 		if (_Oldcapacity > max_size() - _Oldcapacity / 2)

  0000d	8b ca		 mov	 ecx, edx
  0000f	d1 e9		 shr	 ecx, 1
  00011	2b c1		 sub	 eax, ecx
  00013	3b d0		 cmp	 edx, eax
  00015	77 09		 ja	 SHORT $LN31@Calculate_

; 1857 : 			{
; 1858 : 			return (_Newsize);	// geometric growth would overflow
; 1859 : 			}
; 1860 : 
; 1861 : 		const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00017	8d 04 11	 lea	 eax, DWORD PTR [ecx+edx]

; 1862 : 
; 1863 : 		if (_Geometric < _Newsize)

  0001a	3b 44 24 04	 cmp	 eax, DWORD PTR __Newsize$[esp-4]
  0001e	73 04		 jae	 SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1864 : 			{
; 1865 : 			return (_Newsize);	// geometric growth would be insufficient

  00020	8b 44 24 04	 mov	 eax, DWORD PTR __Newsize$[esp-4]
$LN1@Calculate_:

; 1866 : 			}
; 1867 : 
; 1868 : 		return (_Geometric);	// geometric growth is sufficient
; 1869 : 		}

  00024	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1849 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1850 : 		}

  00000	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	ff 74 24 14	 push	 DWORD PTR __Dest$[esp+4]
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1845 : 		}

  00018	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility

; 2402 : 	const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR __First$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR __Last$[esp-4]
  00008	2b c1		 sub	 eax, ecx

; 2403 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

  0000a	50		 push	 eax
  0000b	51		 push	 ecx
  0000c	ff 74 24 14	 push	 DWORD PTR __Dest$[esp+4]
  00010	e8 00 00 00 00	 call	 _memmove
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1834 : 		}

  00018	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<int,std::allocator<int> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Udefault@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHI@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
?_Udefault@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHI@Z PROC ; std::vector<int,std::allocator<int> >::_Udefault, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00004	56		 push	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00005	8b 74 24 08	 mov	 esi, DWORD PTR __Dest$[esp]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1811 : 		{	// fill raw _Dest with _Count value-initialized objects, using allocator

  00009	57		 push	 edi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0000a	8d 3c 85 00 00
	00 00		 lea	 edi, DWORD PTR [eax*4]

; 313  : 	_CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  00011	57		 push	 edi
  00012	6a 00		 push	 0
  00014	56		 push	 esi
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 336  : 	return (_Zero_range(_First, _First + _Count));

  0001d	8d 04 37	 lea	 eax, DWORD PTR [edi+esi]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1812 : 		return (_Uninitialized_value_construct_n(_Dest, _Count, this->_Getal()));

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi

; 1813 : 		}

  00022	c2 08 00	 ret	 8
?_Udefault@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAHI@Z ENDP ; std::vector<int,std::allocator<int> >::_Udefault
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1741 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1742 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1743 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1744 : 
; 1745 : 		return (this->_Myfirst()[_Pos]);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00006	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1746 : 		}

  00009	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1716 : 		}

  00008	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1709 : 		return (_Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 1710 : 			_Alty_traits::max_size(this->_Getal())));
; 1711 : 		}

  00005	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC	; std::vector<int,std::allocator<int> >::size, COMDAT
; _this$ = ecx

; 1704 : 		return (static_cast<size_type>(this->_Mylast() - this->_Myfirst()));

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	2b 01		 sub	 eax, DWORD PTR [ecx]
  00005	c1 f8 02	 sar	 eax, 2

; 1705 : 		}

  00008	c3		 ret	 0
?size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP	; std::vector<int,std::allocator<int> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 41   : 		: _Ptr(_Parg)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00007	89 08		 mov	 DWORD PTR [eax], ecx

; 1629 : 		return (iterator(this->_Mylast(), _STD addressof(this->_Get_data())));
; 1630 : 		}

  00009	c2 04 00	 ret	 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 41   : 		: _Ptr(_Parg)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR ___$ReturnUdt$[esp-4]
  00004	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00006	89 08		 mov	 DWORD PTR [eax], ecx

; 1619 : 		return (iterator(this->_Myfirst(), _STD addressof(this->_Get_data())));
; 1620 : 		}

  00008	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::vector<int,std::allocator<int> >::resize, COMDAT
; _this$ = ecx

; 1477 : 		const auto _Lambda_default = [this](pointer _Dest, const size_type _Count)
; 1478 : 			{
; 1479 : 			return (_Udefault(_Dest, _Count));
; 1480 : 			};
; 1481 : 
; 1482 : 		_Resize(_Newsize, _Lambda_default);

  00000	51		 push	 ecx
  00001	ff 74 24 08	 push	 DWORD PTR __Newsize$[esp]
  00005	e8 00 00 00 00	 call	 ??$_Resize@V<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@?$vector@HV?$allocator@H@std@@@std@@AAEXIV<lambda_4f2fd6a84b983411848f0e0333d0ea32>@@@Z ; std::vector<int,std::allocator<int> >::_Resize<<lambda_4f2fd6a84b983411848f0e0333d0ea32> >

; 1483 : 		}

  0000a	c2 04 00	 ret	 4
?resize@?$vector@HV?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 893  : 		{	// destroy the object

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 1913 : 		if (this->_Myfirst() != pointer())

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	85 c0		 test	 eax, eax
  00007	74 40		 je	 SHORT $LN4@vector

; 1715 : 		return (static_cast<size_type>(this->_Myend() - this->_Myfirst()));

  00009	8b 56 08	 mov	 edx, DWORD PTR [esi+8]
  0000c	2b d0		 sub	 edx, eax
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  0000e	83 e2 fc	 and	 edx, -4			; fffffffcH

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  00011	81 fa 00 10 00
	00		 cmp	 edx, 4096		; 00001000H
  00017	72 12		 jb	 SHORT $LN80@vector

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00019	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  0001c	83 c2 23	 add	 edx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001f	2b c1		 sub	 eax, ecx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00021	83 c0 fc	 add	 eax, -4			; fffffffcH
  00024	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00027	77 22		 ja	 SHORT $LN77@vector

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00029	8b c1		 mov	 eax, ecx
$LN80@vector:

; 207  : 	::operator delete(_Ptr, _Bytes);

  0002b	52		 push	 edx
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1918 : 			this->_Myfirst() = pointer();

  00032	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 207  : 	::operator delete(_Ptr, _Bytes);

  00038	83 c4 08	 add	 esp, 8
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1919 : 			this->_Mylast() = pointer();

  0003b	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], 0

; 1920 : 			this->_Myend() = pointer();

  00042	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], 0
$LN4@vector:
  00049	5e		 pop	 esi

; 895  : 		}

  0004a	c3		 ret	 0
$LN77@vector:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0004b	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN103@vector:
  00050	cc		 int	 3
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 652  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 652  : 		}

  00016	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 297  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 298  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 292  : 		return (*this);

  00000	8b c1		 mov	 eax, ecx

; 293  : 		}

  00002	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 393  : 		}

  00006	8b c1		 mov	 eax, ecx
  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00016	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend, COMDAT
; _this$ = ecx

; 601  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 602  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend, COMDAT
; _this$ = ecx

; 596  : 		return (_Get_data()._Myend);

  00000	8d 41 08	 lea	 eax, DWORD PTR [ecx+8]

; 597  : 		}

  00003	c3		 ret	 0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast, COMDAT
; _this$ = ecx

; 591  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 592  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast, COMDAT
; _this$ = ecx

; 586  : 		return (_Get_data()._Mylast);

  00000	8d 41 04	 lea	 eax, DWORD PTR [ecx+4]

; 587  : 		}

  00003	c3		 ret	 0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal, COMDAT
; _this$ = ecx

; 550  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 551  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal, COMDAT
; _this$ = ecx

; 545  : 		return (_Mypair._Get_first());

  00000	8b c1		 mov	 eax, ecx

; 546  : 		}

  00002	c3		 ret	 0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 535  : 		_Get_data()._Orphan_all();
; 536  : 		}

  00000	c3		 ret	 0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 389  : 		: _Myfirst(),

  00000	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 423  : 		}

  00006	8b c1		 mov	 eax, ecx

; 390  : 		_Mylast(),

  00008	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 391  : 		_Myend()

  0000f	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 423  : 		}

  00016	c3		 ret	 0
??0?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 892  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 893  : 		}

  00005	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 25   : 	size_t _Result = _Count * _Ty_size;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]

; 26   : 	if (_Max_possible < _Count)

  0000b	3d ff ff ff 3f	 cmp	 eax, 1073741823		; 3fffffffH
  00010	76 05		 jbe	 SHORT $LN4@allocate

; 27   : 		{	// multiply overflow, try allocating all of memory and assume the
; 28   : 			// allocation function will throw bad_alloc
; 29   : 		_Result = static_cast<size_t>(-1);

  00012	83 c9 ff	 or	 ecx, -1

; 182  : 	if (_Bytes >= _Big_allocation_threshold)

  00015	eb 08		 jmp	 SHORT $LN27@allocate
$LN4@allocate:
  00017	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  0001d	72 26		 jb	 SHORT $LN7@allocate
$LN27@allocate:

; 93   : 	size_t _Block_size = _Non_user_size + _Bytes;

  0001f	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]

; 94   : 	if (_Block_size <= _Bytes)

  00022	83 ca ff	 or	 edx, -1
  00025	3b c1		 cmp	 eax, ecx
  00027	0f 46 c2	 cmovbe	 eax, edx

; 52   : 		return (::operator new(_Bytes));

  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new

; 100  : 	const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00030	8b c8		 mov	 ecx, eax

; 52   : 		return (::operator new(_Bytes));

  00032	83 c4 04	 add	 esp, 4

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  00035	85 c9		 test	 ecx, ecx
  00037	74 21		 je	 SHORT $LN16@allocate

; 102  : 	void * const _Ptr = reinterpret_cast<void *>((_Ptr_container + _Non_user_size)
; 103  : 		& ~(_Big_allocation_alignment - 1));

  00039	8d 41 23	 lea	 eax, DWORD PTR [ecx+35]
  0003c	83 e0 e0	 and	 eax, -32		; ffffffe0H

; 104  : 	static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003f	89 48 fc	 mov	 DWORD PTR [eax-4], ecx

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00042	c2 04 00	 ret	 4
$LN7@allocate:

; 188  : 	if (_Bytes != 0)

  00045	85 c9		 test	 ecx, ecx
  00047	74 0c		 je	 SHORT $LN8@allocate

; 52   : 		return (::operator new(_Bytes));

  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0004f	83 c4 04	 add	 esp, 4

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00052	c2 04 00	 ret	 4
$LN8@allocate:

; 193  : 	return (nullptr);

  00055	33 c0		 xor	 eax, eax

; 997  : 		return (static_cast<_Ty *>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count))));
; 998  : 		}

  00057	c2 04 00	 ret	 4
$LN16@allocate:

; 101  : 	_STL_VERIFY(_Ptr_container != 0, "invalid argument");	// validate even in release since we're doing p[-1]

  0005a	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN28@allocate:
  0005f	cc		 int	 3
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 991  : 		// no overflow check on the following multiply; we assume _Allocate did that check
; 992  : 		_Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Count$[esp-4]
  00004	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  0000b	8b 44 24 04	 mov	 eax, DWORD PTR __Ptr$[esp-4]

; 201  : 	if (_Bytes >= _Big_allocation_threshold)

  0000f	81 f9 00 10 00
	00		 cmp	 ecx, 4096		; 00001000H
  00015	72 12		 jb	 SHORT $LN15@deallocate

; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00017	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]
  0001a	83 c1 23	 add	 ecx, 35			; 00000023H

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  0001d	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001f	83 c0 fc	 add	 eax, -4			; fffffffcH
  00022	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00025	77 0f		 ja	 SHORT $LN12@deallocate

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00027	8b c2		 mov	 eax, edx
$LN15@deallocate:

; 207  : 	::operator delete(_Ptr, _Bytes);

  00029	51		 push	 ecx
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00030	83 c4 08	 add	 esp, 8

; 993  : 		}

  00033	c2 08 00	 ret	 8
$LN12@deallocate:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00036	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
$LN18@deallocate:
  0003b	cc		 int	 3
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 980  : 		{	// construct default allocator (do nothing)
; 981  : 		}

  00000	8b c1		 mov	 eax, ecx
  00002	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 115  : 	_Bytes += _Non_user_size;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR __Bytes$[esp-4]

; 116  : 
; 117  : 	const uintptr_t * const _Ptr_user = reinterpret_cast<uintptr_t *>(_Ptr);
; 118  : 	const uintptr_t _Ptr_container = _Ptr_user[-1];

  00004	8b 4c 24 04	 mov	 ecx, DWORD PTR __Ptr$[esp-4]
  00008	83 00 23	 add	 DWORD PTR [eax], 35	; 00000023H
  0000b	8b 01		 mov	 eax, DWORD PTR [ecx]
  0000d	8b 50 fc	 mov	 edx, DWORD PTR [eax-4]

; 119  : 
; 120  : 	// If the following asserts, it likely means that we are performing
; 121  : 	// an aligned delete on memory coming from an unaligned allocation.
; 122  : 	_STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 123  : 
; 124  : 	// Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 125  : 	// in range [_Min_back_shift, _Non_user_size]
; 126  :   #ifdef _DEBUG
; 127  : 	constexpr uintptr_t _Min_back_shift = 2 * sizeof(void *);
; 128  :   #else /* ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv */
; 129  : 	constexpr uintptr_t _Min_back_shift = sizeof(void *);
; 130  :   #endif /* _DEBUG */
; 131  : 	const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00010	2b c2		 sub	 eax, edx

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00012	83 c0 fc	 add	 eax, -4			; fffffffcH
  00015	83 f8 1f	 cmp	 eax, 31			; 0000001fH
  00018	77 03		 ja	 SHORT $LN7@Adjust_man

; 133  : 	_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0001a	89 11		 mov	 DWORD PTR [ecx], edx

; 134  : 	}

  0001c	c3		 ret	 0
$LN7@Adjust_man:

; 132  : 	_STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0001d	e9 00 00 00 00	 jmp	 __invalid_parameter_noinfo_noreturn
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xmemory0
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 52   : 		return (::operator new(_Bytes));

  00000	e9 00 00 00 00	 jmp	 ??2@YAPAXI@Z		; operator new
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 54   : 		}

  00000	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 43   : 		}

  00000	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 617  : 		return (INT_MAX);

  00000	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 618  : 		}

  00005	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
END
