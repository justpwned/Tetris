; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26726.0 

	TITLE	C:\Dev\Tetris\src\piece.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?random_int@@YAHHH@Z				; random_int
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	?GetValue@Matrix@math@core@@QBEHHH@Z		; core::math::Matrix::GetValue
PUBLIC	?SetValue@Matrix@math@core@@QAEXHHH@Z		; core::math::Matrix::SetValue
PUBLIC	?GetSide@Tetromino@gameplay@core@@QBEHXZ	; core::gameplay::Tetromino::GetSide
PUBLIC	?SetCellValue@Board@gameplay@core@@QAEXHHH@Z	; core::gameplay::Board::SetCellValue
PUBLIC	?GetCellValue@Board@gameplay@core@@QBEHHH@Z	; core::gameplay::Board::GetCellValue
PUBLIC	?GetBoardCols@Board@gameplay@core@@QBEHXZ	; core::gameplay::Board::GetBoardCols
PUBLIC	?GetBoardRows@Board@gameplay@core@@QBEHXZ	; core::gameplay::Board::GetBoardRows
PUBLIC	?IsValid@Piece@gameplay@core@@QAE_NXZ		; core::gameplay::Piece::IsValid
PUBLIC	?MergeWithBoard@Piece@gameplay@core@@QAEXXZ	; core::gameplay::Piece::MergeWithBoard
PUBLIC	?HardDrop@Piece@gameplay@core@@QAEXXZ		; core::gameplay::Piece::HardDrop
PUBLIC	?SoftDrop@Piece@gameplay@core@@QAE_NXZ		; core::gameplay::Piece::SoftDrop
PUBLIC	?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ	; core::gameplay::Piece::SpawnNewPiece
PUBLIC	?DrawPiece@Piece@gameplay@core@@QAEXHH_N@Z	; core::gameplay::Piece::DrawPiece
PUBLIC	??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@ ; `string'
PUBLIC	??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@ ; `string'
EXTRN	_rand:PROC
EXTRN	__wassert:PROC
EXTRN	?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z:PROC ; core::gameplay::Tetromino::GetValue
EXTRN	?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ:PROC ; core::gameplay::Stats::GetTimeToNextDrop
EXTRN	?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z:PROC ; core::gameplay::Board::DrawCell
EXTRN	?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B:BYTE ; core::gameplay::Tetromino::s_tetrominos
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
CONST	SEGMENT
??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@ DB 'r'
	DB	00H, 'o', 00H, 'w', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'o'
	DB	00H, 'w', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H
	DB	'r', 00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'c'
	DB	00H, 'o', 00H, 'l', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
CONST	SEGMENT
??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'd', 00H, 'e', 00H, 'v', 00H, '\', 00H
	DB	't', 00H, 'e', 00H, 't', 00H, 'r', 00H, 'i', 00H, 's', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'm', 00H, 'a', 00H
	DB	't', 00H, 'h', 00H, '\', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'x', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\piece.cpp
;	COMDAT ?DrawPiece@Piece@gameplay@core@@QAEXHH_N@Z
_TEXT	SEGMENT
_tetromino$ = -8					; size = 8
_t_xOffset$ = 8						; size = 4
_t_yOffset$ = 12					; size = 4
_outline$ = 16						; size = 1
?DrawPiece@Piece@gameplay@core@@QAEXHH_N@Z PROC		; core::gameplay::Piece::DrawPiece, COMDAT
; _this$ = ecx

; 82   : {

  00000	83 ec 08	 sub	 esp, 8
  00003	53		 push	 ebx
  00004	57		 push	 edi
  00005	8b f9		 mov	 edi, ecx

; 83   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];
; 84   :     
; 85   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00007	33 db		 xor	 ebx, ebx
  00009	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0000c	8b 04 d5 00 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8]
  00013	89 44 24 08	 mov	 DWORD PTR _tetromino$[esp+16], eax
  00017	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8+4]
  0001e	89 44 24 0c	 mov	 DWORD PTR _tetromino$[esp+20], eax
  00022	85 c0		 test	 eax, eax
  00024	7e 52		 jle	 SHORT $LN3@DrawPiece
  00026	55		 push	 ebp
  00027	8b 6c 24 1c	 mov	 ebp, DWORD PTR _t_yOffset$[esp+16]
  0002b	56		 push	 esi
  0002c	0f 1f 40 00	 npad	 4
$LL4@DrawPiece:

; 86   :     {
; 87   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00030	33 f6		 xor	 esi, esi
  00032	85 c0		 test	 eax, eax
  00034	7e 3b		 jle	 SHORT $LN2@DrawPiece
$LL7@DrawPiece:

; 88   :         {
; 89   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00036	ff 77 18	 push	 DWORD PTR [edi+24]
  00039	8d 4c 24 14	 lea	 ecx, DWORD PTR _tetromino$[esp+28]
  0003d	56		 push	 esi
  0003e	53		 push	 ebx
  0003f	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue
  00044	0f b6 c0	 movzx	 eax, al

; 90   :             if (value)

  00047	85 c0		 test	 eax, eax
  00049	74 1d		 je	 SHORT $LN5@DrawPiece

; 91   :             {
; 92   :                 m_board->DrawCell(row + m_rowOffset, col + m_colOffset, value, t_xOffset, t_yOffset, outline);

  0004b	ff 74 24 24	 push	 DWORD PTR _outline$[esp+20]
  0004f	8b 0f		 mov	 ecx, DWORD PTR [edi]
  00051	55		 push	 ebp
  00052	ff 74 24 24	 push	 DWORD PTR _t_xOffset$[esp+28]
  00056	50		 push	 eax
  00057	8b 47 14	 mov	 eax, DWORD PTR [edi+20]
  0005a	03 c6		 add	 eax, esi
  0005c	50		 push	 eax
  0005d	8b 47 10	 mov	 eax, DWORD PTR [edi+16]
  00060	03 c3		 add	 eax, ebx
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z ; core::gameplay::Board::DrawCell
$LN5@DrawPiece:

; 86   :     {
; 87   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00068	8b 44 24 14	 mov	 eax, DWORD PTR _tetromino$[esp+28]
  0006c	46		 inc	 esi
  0006d	3b f0		 cmp	 esi, eax
  0006f	7c c5		 jl	 SHORT $LL7@DrawPiece
$LN2@DrawPiece:

; 83   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];
; 84   :     
; 85   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00071	43		 inc	 ebx
  00072	3b d8		 cmp	 ebx, eax
  00074	7c ba		 jl	 SHORT $LL4@DrawPiece
  00076	5e		 pop	 esi
  00077	5d		 pop	 ebp
$LN3@DrawPiece:
  00078	5f		 pop	 edi

; 93   :             }
; 94   :         }
; 95   :     }
; 96   : }

  00079	5b		 pop	 ebx
  0007a	83 c4 08	 add	 esp, 8
  0007d	c2 0c 00	 ret	 12			; 0000000cH
?DrawPiece@Piece@gameplay@core@@QAEXHH_N@Z ENDP		; core::gameplay::Piece::DrawPiece
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
;	COMDAT ?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ
_TEXT	SEGMENT
?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ PROC		; core::gameplay::Piece::SpawnNewPiece, COMDAT
; _this$ = ecx

; 73   : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  00004	e8 00 00 00 00	 call	 _rand
  00009	8b d0		 mov	 edx, eax
; File c:\dev\tetris\src\piece.cpp

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  0000b	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  0000e	b8 3f c0 fa 6f	 mov	 eax, 1878704191		; 6ffac03fH
; File c:\dev\tetris\src\piece.cpp

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  00013	8b 77 04	 mov	 esi, DWORD PTR [edi+4]
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  00016	f7 ea		 imul	 edx
  00018	c1 fa 0b	 sar	 edx, 11			; 0000000bH
  0001b	8b c2		 mov	 eax, edx
  0001d	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00020	03 c2		 add	 eax, edx
; File c:\dev\tetris\src\piece.cpp

; 74   :     m_tetrominoIndex = random_int(0, Tetromino::s_numberOfTetrominos - 1);

  00022	89 47 0c	 mov	 DWORD PTR [edi+12], eax

; 75   :     m_colOffset = m_board->GetBoardCols() / 2 - 1;

  00025	8b 07		 mov	 eax, DWORD PTR [edi]
  00027	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0002a	99		 cdq
  0002b	2b c2		 sub	 eax, edx

; 76   :     m_rowOffset = 0;

  0002d	c7 47 10 00 00
	00 00		 mov	 DWORD PTR [edi+16], 0
  00034	d1 f8		 sar	 eax, 1
  00036	48		 dec	 eax

; 77   :     m_rotation = 0;

  00037	c7 47 18 00 00
	00 00		 mov	 DWORD PTR [edi+24], 0
  0003e	89 47 14	 mov	 DWORD PTR [edi+20], eax

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  00041	e8 00 00 00 00	 call	 ?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ ; core::gameplay::Stats::GetTimeToNextDrop
  00046	d8 46 08	 fadd	 DWORD PTR [esi+8]
  00049	5f		 pop	 edi
  0004a	d9 1e		 fstp	 DWORD PTR [esi]
  0004c	5e		 pop	 esi

; 79   : }

  0004d	c3		 ret	 0
?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ ENDP		; core::gameplay::Piece::SpawnNewPiece
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
;	COMDAT ?SoftDrop@Piece@gameplay@core@@QAE_NXZ
_TEXT	SEGMENT
tv578 = -24						; size = 4
_col$1$ = -24						; size = 4
_row$1$ = -20						; size = 4
_row$1$ = -20						; size = 4
_value$1$ = -16						; size = 4
_tetromino$1 = -16					; size = 8
_tetromino$2 = -8					; size = 8
?SoftDrop@Piece@gameplay@core@@QAE_NXZ PROC		; core::gameplay::Piece::SoftDrop, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	53		 push	 ebx
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b e9		 mov	 ebp, ecx

; 7    :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];

  0000f	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]

; 8    :     
; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00012	33 ff		 xor	 edi, edi

; 58   :     ++m_rowOffset;

  00014	ff 45 10	 inc	 DWORD PTR [ebp+16]

; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00017	89 7c 24 14	 mov	 DWORD PTR _row$1$[esp+40], edi
  0001b	8b 04 d5 00 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8]
  00022	89 44 24 18	 mov	 DWORD PTR _tetromino$1[esp+40], eax
  00026	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8+4]
  0002d	89 44 24 1c	 mov	 DWORD PTR _tetromino$1[esp+44], eax
  00031	85 c0		 test	 eax, eax
  00033	0f 8e 9b 00 00
	00		 jle	 $LN88@SoftDrop
  00039	0f 1f 80 00 00
	00 00		 npad	 7
$LL7@SoftDrop:

; 10   :     {
; 11   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00040	33 f6		 xor	 esi, esi
  00042	89 74 24 10	 mov	 DWORD PTR _col$1$[esp+40], esi
  00046	85 c0		 test	 eax, eax
  00048	7e 7d		 jle	 SHORT $LN5@SoftDrop
  0004a	66 0f 1f 44 00
	00		 npad	 6
$LL10@SoftDrop:

; 12   :         {
; 13   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00050	ff 75 18	 push	 DWORD PTR [ebp+24]
  00053	8d 4c 24 1c	 lea	 ecx, DWORD PTR _tetromino$1[esp+44]
  00057	56		 push	 esi
  00058	57		 push	 edi
  00059	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue

; 14   :             if (value)

  0005e	84 c0		 test	 al, al
  00060	74 58		 je	 SHORT $LN8@SoftDrop

; 15   :             {
; 16   :                 i32 boardRow = m_rowOffset + row;

  00062	8b 5d 10	 mov	 ebx, DWORD PTR [ebp+16]
  00065	03 df		 add	 ebx, edi

; 17   :                 i32 boardCol = m_colOffset + col;

  00067	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]
  0006a	03 fe		 add	 edi, esi

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  0006c	85 db		 test	 ebx, ebx
  0006e	78 7e		 js	 SHORT $LN86@SoftDrop
; File c:\dev\tetris\src\board.hpp

; 56   :             inline i32 GetBoardRows()        const { return m_boardRows; }

  00070	8b 75 00	 mov	 esi, DWORD PTR [ebp]
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  00073	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  00076	7d 76		 jge	 SHORT $LN86@SoftDrop
  00078	85 ff		 test	 edi, edi
  0007a	78 72		 js	 SHORT $LN86@SoftDrop
  0007c	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0007f	7d 6d		 jge	 SHORT $LN86@SoftDrop
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00081	3b 5e 14	 cmp	 ebx, DWORD PTR [esi+20]
  00084	7d 07		 jge	 SHORT $LN87@SoftDrop
  00086	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00089	3b f9		 cmp	 edi, ecx
  0008b	7c 17		 jl	 SHORT $LN28@SoftDrop
$LN87@SoftDrop:
  0008d	6a 52		 push	 82			; 00000052H
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00099	e8 00 00 00 00	 call	 __wassert
  0009e	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN28@SoftDrop:
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  000a4	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  000a7	0f af cb	 imul	 ecx, ebx
  000aa	03 cf		 add	 ecx, edi
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  000ac	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000b0	75 3c		 jne	 SHORT $LN86@SoftDrop
  000b2	8b 74 24 10	 mov	 esi, DWORD PTR _col$1$[esp+40]
  000b6	8b 7c 24 14	 mov	 edi, DWORD PTR _row$1$[esp+40]
$LN8@SoftDrop:

; 10   :     {
; 11   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  000ba	8b 44 24 1c	 mov	 eax, DWORD PTR _tetromino$1[esp+44]
  000be	46		 inc	 esi
  000bf	89 74 24 10	 mov	 DWORD PTR _col$1$[esp+40], esi
  000c3	3b f0		 cmp	 esi, eax
  000c5	7c 89		 jl	 SHORT $LL10@SoftDrop
$LN5@SoftDrop:

; 8    :     
; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  000c7	47		 inc	 edi
  000c8	89 7c 24 14	 mov	 DWORD PTR _row$1$[esp+40], edi
  000cc	3b f8		 cmp	 edi, eax
  000ce	0f 8c 6c ff ff
	ff		 jl	 $LL7@SoftDrop
$LN88@SoftDrop:

; 62   :         MergeWithBoard();
; 63   :         SpawnNewPiece();
; 64   :         
; 65   :         return false;
; 66   :     }
; 67   :     
; 68   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  000d4	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000d7	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]
  000da	e8 00 00 00 00	 call	 ?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ ; core::gameplay::Stats::GetTimeToNextDrop

; 69   :     return true;
; 70   : }

  000df	d8 46 08	 fadd	 DWORD PTR [esi+8]
  000e2	b0 01		 mov	 al, 1
  000e4	d9 1e		 fstp	 DWORD PTR [esi]
  000e6	5f		 pop	 edi
  000e7	5e		 pop	 esi
  000e8	5d		 pop	 ebp
  000e9	5b		 pop	 ebx
  000ea	8b e5		 mov	 esp, ebp
  000ec	5d		 pop	 ebp
  000ed	c3		 ret	 0
$LN86@SoftDrop:

; 39   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];

  000ee	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]

; 40   :     
; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  000f1	33 ff		 xor	 edi, edi

; 59   :     if (!IsValid())
; 60   :     {
; 61   :         --m_rowOffset;

  000f3	ff 4d 10	 dec	 DWORD PTR [ebp+16]

; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  000f6	89 7c 24 14	 mov	 DWORD PTR _row$1$[esp+40], edi
  000fa	8b 04 cd 00 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8]
  00101	89 44 24 20	 mov	 DWORD PTR _tetromino$2[esp+40], eax
  00105	8b 04 cd 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8+4]
  0010c	89 44 24 24	 mov	 DWORD PTR _tetromino$2[esp+44], eax
  00110	85 c0		 test	 eax, eax
  00112	0f 8e 8a 00 00
	00		 jle	 $LN39@SoftDrop
$LL40@SoftDrop:

; 43   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00118	33 f6		 xor	 esi, esi
  0011a	85 c0		 test	 eax, eax
  0011c	7e 77		 jle	 SHORT $LN38@SoftDrop
  0011e	66 90		 npad	 2
$LL43@SoftDrop:

; 44   :         {
; 45   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00120	ff 75 18	 push	 DWORD PTR [ebp+24]
  00123	8d 4c 24 24	 lea	 ecx, DWORD PTR _tetromino$2[esp+44]
  00127	56		 push	 esi
  00128	57		 push	 edi
  00129	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue
  0012e	0f b6 c0	 movzx	 eax, al
  00131	89 44 24 18	 mov	 DWORD PTR _value$1$[esp+40], eax

; 46   :             if (value)

  00135	85 c0		 test	 eax, eax
  00137	74 53		 je	 SHORT $LN41@SoftDrop

; 48   :                 i32 boardRow = m_rowOffset + row;

  00139	8b 5d 10	 mov	 ebx, DWORD PTR [ebp+16]
; File c:\dev\tetris\src\board.hpp

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  0013c	8b 45 00	 mov	 eax, DWORD PTR [ebp]
; File c:\dev\tetris\src\piece.cpp

; 48   :                 i32 boardRow = m_rowOffset + row;

  0013f	03 df		 add	 ebx, edi

; 49   :                 i32 boardCol = m_colOffset + col;

  00141	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]
  00144	03 fe		 add	 edi, esi
; File c:\dev\tetris\src\board.hpp

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  00146	89 44 24 10	 mov	 DWORD PTR tv578[esp+40], eax
; File c:\dev\tetris\src\math\matrix.hpp

; 88   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  0014a	85 db		 test	 ebx, ebx
  0014c	78 10		 js	 SHORT $LN54@SoftDrop
  0014e	3b 58 14	 cmp	 ebx, DWORD PTR [eax+20]
  00151	7d 0b		 jge	 SHORT $LN54@SoftDrop
  00153	85 ff		 test	 edi, edi
  00155	78 07		 js	 SHORT $LN54@SoftDrop
  00157	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0015a	3b f9		 cmp	 edi, ecx
  0015c	7c 1b		 jl	 SHORT $LN55@SoftDrop
$LN54@SoftDrop:
  0015e	6a 58		 push	 88			; 00000058H
  00160	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00165	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0016a	e8 00 00 00 00	 call	 __wassert
  0016f	8b 44 24 1c	 mov	 eax, DWORD PTR tv578[esp+52]
  00173	83 c4 0c	 add	 esp, 12			; 0000000cH
  00176	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
$LN55@SoftDrop:

; 89   :                 m_data[row * m_cols + col] = value;

  00179	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  0017c	8b 54 24 18	 mov	 edx, DWORD PTR _value$1$[esp+40]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00180	0f af cb	 imul	 ecx, ebx
  00183	03 cf		 add	 ecx, edi
  00185	8b 7c 24 14	 mov	 edi, DWORD PTR _row$1$[esp+40]
; File c:\dev\tetris\src\math\matrix.hpp

; 89   :                 m_data[row * m_cols + col] = value;

  00189	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN41@SoftDrop:
; File c:\dev\tetris\src\piece.cpp

; 43   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  0018c	8b 44 24 24	 mov	 eax, DWORD PTR _tetromino$2[esp+44]
  00190	46		 inc	 esi
  00191	3b f0		 cmp	 esi, eax
  00193	7c 8b		 jl	 SHORT $LL43@SoftDrop
$LN38@SoftDrop:

; 40   :     
; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00195	47		 inc	 edi
  00196	89 7c 24 14	 mov	 DWORD PTR _row$1$[esp+40], edi
  0019a	3b f8		 cmp	 edi, eax
  0019c	0f 8c 76 ff ff
	ff		 jl	 $LL40@SoftDrop
$LN39@SoftDrop:
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  001a2	e8 00 00 00 00	 call	 _rand
  001a7	8b c8		 mov	 ecx, eax
; File c:\dev\tetris\src\piece.cpp

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  001a9	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  001ac	b8 3f c0 fa 6f	 mov	 eax, 1878704191		; 6ffac03fH
  001b1	f7 e9		 imul	 ecx
; File c:\dev\tetris\src\piece.cpp

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  001b3	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  001b6	c1 fa 0b	 sar	 edx, 11			; 0000000bH
  001b9	8b c2		 mov	 eax, edx
  001bb	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001be	03 c2		 add	 eax, edx
; File c:\dev\tetris\src\piece.cpp

; 74   :     m_tetrominoIndex = random_int(0, Tetromino::s_numberOfTetrominos - 1);

  001c0	89 45 0c	 mov	 DWORD PTR [ebp+12], eax

; 75   :     m_colOffset = m_board->GetBoardCols() / 2 - 1;

  001c3	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  001c6	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001c9	99		 cdq
  001ca	2b c2		 sub	 eax, edx

; 76   :     m_rowOffset = 0;

  001cc	c7 45 10 00 00
	00 00		 mov	 DWORD PTR [ebp+16], 0
  001d3	d1 f8		 sar	 eax, 1
  001d5	48		 dec	 eax

; 77   :     m_rotation = 0;

  001d6	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [ebp+24], 0
  001dd	89 45 14	 mov	 DWORD PTR [ebp+20], eax

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  001e0	e8 00 00 00 00	 call	 ?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ ; core::gameplay::Stats::GetTimeToNextDrop

; 69   :     return true;
; 70   : }

  001e5	d8 46 08	 fadd	 DWORD PTR [esi+8]
  001e8	5f		 pop	 edi
  001e9	32 c0		 xor	 al, al
  001eb	d9 1e		 fstp	 DWORD PTR [esi]
  001ed	5e		 pop	 esi
  001ee	5d		 pop	 ebp
  001ef	5b		 pop	 ebx
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c3		 ret	 0
?SoftDrop@Piece@gameplay@core@@QAE_NXZ ENDP		; core::gameplay::Piece::SoftDrop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\piece.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\common_utils.h
; File c:\dev\tetris\src\piece.cpp
;	COMDAT ?HardDrop@Piece@gameplay@core@@QAEXXZ
_TEXT	SEGMENT
_row$1$ = -28						; size = 4
_row$1$ = -28						; size = 4
tv588 = -24						; size = 4
_boardRow$1$ = -24					; size = 4
_value$1$ = -20						; size = 4
_tetromino$1 = -16					; size = 8
_tetromino$2 = -8					; size = 8
?HardDrop@Piece@gameplay@core@@QAEXXZ PROC		; core::gameplay::Piece::HardDrop, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 20	 sub	 esp, 32			; 00000020H
  00009	53		 push	 ebx
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b e9		 mov	 ebp, ecx
  0000f	90		 npad	 1
$LL2@HardDrop:

; 7    :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];

  00010	8b 55 0c	 mov	 edx, DWORD PTR [ebp+12]

; 8    :     
; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00013	33 f6		 xor	 esi, esi

; 58   :     ++m_rowOffset;

  00015	ff 45 10	 inc	 DWORD PTR [ebp+16]

; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00018	89 74 24 14	 mov	 DWORD PTR _row$1$[esp+48], esi
  0001c	8b 04 d5 00 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8]
  00023	89 44 24 20	 mov	 DWORD PTR _tetromino$1[esp+48], eax
  00027	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8+4]
  0002e	89 44 24 24	 mov	 DWORD PTR _tetromino$1[esp+52], eax
  00032	85 c0		 test	 eax, eax
  00034	0f 8e 94 00 00
	00		 jle	 $LN10@HardDrop
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL11@HardDrop:

; 10   :     {
; 11   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00040	33 db		 xor	 ebx, ebx
  00042	85 c0		 test	 eax, eax
  00044	7e 7b		 jle	 SHORT $LN9@HardDrop
$LL14@HardDrop:

; 12   :         {
; 13   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00046	ff 75 18	 push	 DWORD PTR [ebp+24]
  00049	8d 4c 24 24	 lea	 ecx, DWORD PTR _tetromino$1[esp+52]
  0004d	53		 push	 ebx
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue

; 14   :             if (value)

  00054	84 c0		 test	 al, al
  00056	74 60		 je	 SHORT $LN12@HardDrop

; 15   :             {
; 16   :                 i32 boardRow = m_rowOffset + row;

  00058	8b 45 10	 mov	 eax, DWORD PTR [ebp+16]

; 17   :                 i32 boardCol = m_colOffset + col;

  0005b	8b d0		 mov	 edx, eax
  0005d	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]
  00060	03 fb		 add	 edi, ebx
  00062	8d 0c 30	 lea	 ecx, DWORD PTR [eax+esi]
  00065	89 4c 24 18	 mov	 DWORD PTR _boardRow$1$[esp+48], ecx

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  00069	85 c9		 test	 ecx, ecx
  0006b	78 76		 js	 SHORT $LN17@HardDrop
; File c:\dev\tetris\src\board.hpp

; 56   :             inline i32 GetBoardRows()        const { return m_boardRows; }

  0006d	8b 75 00	 mov	 esi, DWORD PTR [ebp]
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  00070	3b 4e 04	 cmp	 ecx, DWORD PTR [esi+4]
  00073	7d 6e		 jge	 SHORT $LN17@HardDrop
  00075	85 ff		 test	 edi, edi
  00077	78 6a		 js	 SHORT $LN17@HardDrop
  00079	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  0007c	7d 65		 jge	 SHORT $LN17@HardDrop
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  0007e	3b 4e 14	 cmp	 ecx, DWORD PTR [esi+20]
  00081	7d 07		 jge	 SHORT $LN95@HardDrop
  00083	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00086	3b f9		 cmp	 edi, ecx
  00088	7c 1a		 jl	 SHORT $LN32@HardDrop
$LN95@HardDrop:
  0008a	6a 52		 push	 82			; 00000052H
  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00096	e8 00 00 00 00	 call	 __wassert
  0009b	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0009e	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a1	8b 55 10	 mov	 edx, DWORD PTR [ebp+16]
$LN32@HardDrop:
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  000a4	0f af 4c 24 18	 imul	 ecx, DWORD PTR _boardRow$1$[esp+48]
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  000a9	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  000ac	03 cf		 add	 ecx, edi
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  000ae	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000b2	75 2f		 jne	 SHORT $LN17@HardDrop
  000b4	8b 74 24 14	 mov	 esi, DWORD PTR _row$1$[esp+48]
$LN12@HardDrop:

; 10   :     {
; 11   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  000b8	8b 44 24 24	 mov	 eax, DWORD PTR _tetromino$1[esp+52]
  000bc	43		 inc	 ebx
  000bd	3b d8		 cmp	 ebx, eax
  000bf	7c 85		 jl	 SHORT $LL14@HardDrop
$LN9@HardDrop:

; 8    :     
; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  000c1	46		 inc	 esi
  000c2	89 74 24 14	 mov	 DWORD PTR _row$1$[esp+48], esi
  000c6	3b f0		 cmp	 esi, eax
  000c8	0f 8c 72 ff ff
	ff		 jl	 $LL11@HardDrop
$LN10@HardDrop:

; 68   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  000ce	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
  000d1	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]
  000d4	e8 00 00 00 00	 call	 ?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ ; core::gameplay::Stats::GetTimeToNextDrop
  000d9	d8 46 08	 fadd	 DWORD PTR [esi+8]
  000dc	d9 1e		 fstp	 DWORD PTR [esi]

; 34   :     while (SoftDrop());

  000de	e9 2d ff ff ff	 jmp	 $LL2@HardDrop
$LN17@HardDrop:

; 39   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];

  000e3	8b 4d 0c	 mov	 ecx, DWORD PTR [ebp+12]

; 61   :         --m_rowOffset;

  000e6	8d 42 ff	 lea	 eax, DWORD PTR [edx-1]
  000e9	89 45 10	 mov	 DWORD PTR [ebp+16], eax

; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  000ec	33 ff		 xor	 edi, edi
  000ee	89 7c 24 14	 mov	 DWORD PTR _row$1$[esp+48], edi
  000f2	8b 04 cd 00 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8]
  000f9	89 44 24 28	 mov	 DWORD PTR _tetromino$2[esp+48], eax
  000fd	8b 04 cd 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8+4]
  00104	89 44 24 2c	 mov	 DWORD PTR _tetromino$2[esp+52], eax
  00108	85 c0		 test	 eax, eax
  0010a	0f 8e 88 00 00
	00		 jle	 $LN43@HardDrop
$LL44@HardDrop:

; 43   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00110	33 f6		 xor	 esi, esi
  00112	85 c0		 test	 eax, eax
  00114	7e 75		 jle	 SHORT $LN42@HardDrop
$LL47@HardDrop:

; 44   :         {
; 45   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00116	ff 75 18	 push	 DWORD PTR [ebp+24]
  00119	8d 4c 24 2c	 lea	 ecx, DWORD PTR _tetromino$2[esp+52]
  0011d	56		 push	 esi
  0011e	57		 push	 edi
  0011f	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue
  00124	0f b6 c0	 movzx	 eax, al
  00127	89 44 24 1c	 mov	 DWORD PTR _value$1$[esp+48], eax

; 46   :             if (value)

  0012b	85 c0		 test	 eax, eax
  0012d	74 53		 je	 SHORT $LN45@HardDrop

; 48   :                 i32 boardRow = m_rowOffset + row;

  0012f	8b 5d 10	 mov	 ebx, DWORD PTR [ebp+16]
; File c:\dev\tetris\src\board.hpp

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  00132	8b 45 00	 mov	 eax, DWORD PTR [ebp]
; File c:\dev\tetris\src\piece.cpp

; 48   :                 i32 boardRow = m_rowOffset + row;

  00135	03 df		 add	 ebx, edi

; 49   :                 i32 boardCol = m_colOffset + col;

  00137	8b 7d 14	 mov	 edi, DWORD PTR [ebp+20]
  0013a	03 fe		 add	 edi, esi
; File c:\dev\tetris\src\board.hpp

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  0013c	89 44 24 18	 mov	 DWORD PTR tv588[esp+48], eax
; File c:\dev\tetris\src\math\matrix.hpp

; 88   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00140	85 db		 test	 ebx, ebx
  00142	78 10		 js	 SHORT $LN58@HardDrop
  00144	3b 58 14	 cmp	 ebx, DWORD PTR [eax+20]
  00147	7d 0b		 jge	 SHORT $LN58@HardDrop
  00149	85 ff		 test	 edi, edi
  0014b	78 07		 js	 SHORT $LN58@HardDrop
  0014d	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00150	3b f9		 cmp	 edi, ecx
  00152	7c 1b		 jl	 SHORT $LN59@HardDrop
$LN58@HardDrop:
  00154	6a 58		 push	 88			; 00000058H
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  0015b	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00160	e8 00 00 00 00	 call	 __wassert
  00165	8b 44 24 24	 mov	 eax, DWORD PTR tv588[esp+60]
  00169	83 c4 0c	 add	 esp, 12			; 0000000cH
  0016c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
$LN59@HardDrop:

; 89   :                 m_data[row * m_cols + col] = value;

  0016f	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  00172	8b 54 24 1c	 mov	 edx, DWORD PTR _value$1$[esp+48]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00176	0f af cb	 imul	 ecx, ebx
  00179	03 cf		 add	 ecx, edi
  0017b	8b 7c 24 14	 mov	 edi, DWORD PTR _row$1$[esp+48]
; File c:\dev\tetris\src\math\matrix.hpp

; 89   :                 m_data[row * m_cols + col] = value;

  0017f	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
$LN45@HardDrop:
; File c:\dev\tetris\src\piece.cpp

; 43   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00182	8b 44 24 2c	 mov	 eax, DWORD PTR _tetromino$2[esp+52]
  00186	46		 inc	 esi
  00187	3b f0		 cmp	 esi, eax
  00189	7c 8b		 jl	 SHORT $LL47@HardDrop
$LN42@HardDrop:

; 40   :     
; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  0018b	47		 inc	 edi
  0018c	89 7c 24 14	 mov	 DWORD PTR _row$1$[esp+48], edi
  00190	3b f8		 cmp	 edi, eax
  00192	0f 8c 78 ff ff
	ff		 jl	 $LL44@HardDrop
$LN43@HardDrop:
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  00198	e8 00 00 00 00	 call	 _rand
  0019d	8b c8		 mov	 ecx, eax
; File c:\dev\tetris\src\piece.cpp

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  0019f	8b 75 04	 mov	 esi, DWORD PTR [ebp+4]
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  001a2	b8 3f c0 fa 6f	 mov	 eax, 1878704191		; 6ffac03fH
  001a7	f7 e9		 imul	 ecx
; File c:\dev\tetris\src\piece.cpp

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  001a9	8b 4d 08	 mov	 ecx, DWORD PTR [ebp+8]
; File c:\dev\tetris\src\common_utils.h

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  001ac	c1 fa 0b	 sar	 edx, 11			; 0000000bH
  001af	8b c2		 mov	 eax, edx
  001b1	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  001b4	03 c2		 add	 eax, edx
; File c:\dev\tetris\src\piece.cpp

; 74   :     m_tetrominoIndex = random_int(0, Tetromino::s_numberOfTetrominos - 1);

  001b6	89 45 0c	 mov	 DWORD PTR [ebp+12], eax

; 75   :     m_colOffset = m_board->GetBoardCols() / 2 - 1;

  001b9	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  001bc	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  001bf	99		 cdq
  001c0	2b c2		 sub	 eax, edx

; 76   :     m_rowOffset = 0;

  001c2	c7 45 10 00 00
	00 00		 mov	 DWORD PTR [ebp+16], 0
  001c9	d1 f8		 sar	 eax, 1
  001cb	48		 dec	 eax

; 77   :     m_rotation = 0;

  001cc	c7 45 18 00 00
	00 00		 mov	 DWORD PTR [ebp+24], 0
  001d3	89 45 14	 mov	 DWORD PTR [ebp+20], eax

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  001d6	e8 00 00 00 00	 call	 ?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ ; core::gameplay::Stats::GetTimeToNextDrop
  001db	d8 46 08	 fadd	 DWORD PTR [esi+8]

; 35   : }

  001de	5f		 pop	 edi

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  001df	d9 1e		 fstp	 DWORD PTR [esi]

; 35   : }

  001e1	5e		 pop	 esi
  001e2	5d		 pop	 ebp
  001e3	5b		 pop	 ebx
  001e4	8b e5		 mov	 esp, ebp
  001e6	5d		 pop	 ebp
  001e7	c3		 ret	 0
?HardDrop@Piece@gameplay@core@@QAEXXZ ENDP		; core::gameplay::Piece::HardDrop
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\piece.cpp
;	COMDAT ?MergeWithBoard@Piece@gameplay@core@@QAEXXZ
_TEXT	SEGMENT
_row$1$ = -20						; size = 4
_value$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
_tetromino$ = -8					; size = 8
?MergeWithBoard@Piece@gameplay@core@@QAEXXZ PROC	; core::gameplay::Piece::MergeWithBoard, COMDAT
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 18	 sub	 esp, 24			; 00000018H
  00009	53		 push	 ebx
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b f9		 mov	 edi, ecx

; 39   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];
; 40   :     
; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  0000f	33 db		 xor	 ebx, ebx
  00011	89 7c 24 1c	 mov	 DWORD PTR _this$1$[esp+40], edi
  00015	89 5c 24 14	 mov	 DWORD PTR _row$1$[esp+40], ebx
  00019	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0001c	8b 04 d5 00 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8]
  00023	89 44 24 20	 mov	 DWORD PTR _tetromino$[esp+40], eax
  00027	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8+4]
  0002e	89 44 24 24	 mov	 DWORD PTR _tetromino$[esp+44], eax
  00032	85 c0		 test	 eax, eax
  00034	0f 8e 85 00 00
	00		 jle	 $LN3@MergeWithB
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@MergeWithB:

; 43   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00040	33 f6		 xor	 esi, esi
  00042	85 c0		 test	 eax, eax
  00044	7e 70		 jle	 SHORT $LN2@MergeWithB
$LL7@MergeWithB:

; 44   :         {
; 45   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00046	ff 77 18	 push	 DWORD PTR [edi+24]
  00049	8d 4c 24 24	 lea	 ecx, DWORD PTR _tetromino$[esp+44]
  0004d	56		 push	 esi
  0004e	53		 push	 ebx
  0004f	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue
  00054	0f b6 c0	 movzx	 eax, al
  00057	89 44 24 18	 mov	 DWORD PTR _value$1$[esp+40], eax

; 46   :             if (value)

  0005b	85 c0		 test	 eax, eax
  0005d	74 4e		 je	 SHORT $LN5@MergeWithB

; 47   :             {
; 48   :                 i32 boardRow = m_rowOffset + row;

  0005f	8b 6f 10	 mov	 ebp, DWORD PTR [edi+16]
  00062	03 eb		 add	 ebp, ebx

; 49   :                 i32 boardCol = m_colOffset + col;

  00064	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]
; File c:\dev\tetris\src\board.hpp

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  00067	8b 3f		 mov	 edi, DWORD PTR [edi]
; File c:\dev\tetris\src\piece.cpp

; 49   :                 i32 boardCol = m_colOffset + col;

  00069	03 de		 add	 ebx, esi
; File c:\dev\tetris\src\math\matrix.hpp

; 88   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  0006b	85 ed		 test	 ebp, ebp
  0006d	78 10		 js	 SHORT $LN18@MergeWithB
  0006f	3b 6f 14	 cmp	 ebp, DWORD PTR [edi+20]
  00072	7d 0b		 jge	 SHORT $LN18@MergeWithB
  00074	85 db		 test	 ebx, ebx
  00076	78 07		 js	 SHORT $LN18@MergeWithB
  00078	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0007b	3b d8		 cmp	 ebx, eax
  0007d	7c 17		 jl	 SHORT $LN19@MergeWithB
$LN18@MergeWithB:
  0007f	6a 58		 push	 88			; 00000058H
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0008b	e8 00 00 00 00	 call	 __wassert
  00090	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00093	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@MergeWithB:

; 89   :                 m_data[row * m_cols + col] = value;

  00096	8b 4f 1c	 mov	 ecx, DWORD PTR [edi+28]
  00099	8b 54 24 18	 mov	 edx, DWORD PTR _value$1$[esp+40]
  0009d	8b 7c 24 1c	 mov	 edi, DWORD PTR _this$1$[esp+40]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  000a1	0f af c5	 imul	 eax, ebp
  000a4	03 c3		 add	 eax, ebx
  000a6	8b 5c 24 14	 mov	 ebx, DWORD PTR _row$1$[esp+40]
; File c:\dev\tetris\src\math\matrix.hpp

; 89   :                 m_data[row * m_cols + col] = value;

  000aa	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx
$LN5@MergeWithB:
; File c:\dev\tetris\src\piece.cpp

; 43   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  000ad	8b 44 24 24	 mov	 eax, DWORD PTR _tetromino$[esp+44]
  000b1	46		 inc	 esi
  000b2	3b f0		 cmp	 esi, eax
  000b4	7c 90		 jl	 SHORT $LL7@MergeWithB
$LN2@MergeWithB:

; 39   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];
; 40   :     
; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  000b6	43		 inc	 ebx
  000b7	89 5c 24 14	 mov	 DWORD PTR _row$1$[esp+40], ebx
  000bb	3b d8		 cmp	 ebx, eax
  000bd	7c 81		 jl	 SHORT $LL4@MergeWithB
$LN3@MergeWithB:

; 50   :                 m_board->SetCellValue(boardRow, boardCol, value);
; 51   :             }
; 52   :         }
; 53   :     }
; 54   : }

  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5d		 pop	 ebp
  000c2	5b		 pop	 ebx
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
?MergeWithBoard@Piece@gameplay@core@@QAEXXZ ENDP	; core::gameplay::Piece::MergeWithBoard
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\piece.cpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\piece.cpp
;	COMDAT ?IsValid@Piece@gameplay@core@@QAE_NXZ
_TEXT	SEGMENT
_row$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
_tetromino$ = -8					; size = 8
?IsValid@Piece@gameplay@core@@QAE_NXZ PROC		; core::gameplay::Piece::IsValid, COMDAT
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	83 ec 10	 sub	 esp, 16			; 00000010H
  00009	53		 push	 ebx
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	57		 push	 edi

; 7    :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];
; 8    :     
; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  0000f	33 ff		 xor	 edi, edi
  00011	89 74 24 14	 mov	 DWORD PTR _this$1$[esp+32], esi
  00015	89 7c 24 10	 mov	 DWORD PTR _row$1$[esp+32], edi
  00019	8b 56 0c	 mov	 edx, DWORD PTR [esi+12]
  0001c	8b 04 d5 00 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8]
  00023	89 44 24 18	 mov	 DWORD PTR _tetromino$[esp+32], eax
  00027	8b 04 d5 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[edx*8+4]
  0002e	89 44 24 1c	 mov	 DWORD PTR _tetromino$[esp+36], eax
  00032	85 c0		 test	 eax, eax
  00034	0f 8e 8b 00 00
	00		 jle	 $LN43@IsValid
  0003a	66 0f 1f 44 00
	00		 npad	 6
$LL4@IsValid:

; 10   :     {
; 11   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00040	33 ed		 xor	 ebp, ebp
  00042	85 c0		 test	 eax, eax
  00044	7e 72		 jle	 SHORT $LN2@IsValid
$LL7@IsValid:

; 12   :         {
; 13   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00046	ff 76 18	 push	 DWORD PTR [esi+24]
  00049	8d 4c 24 1c	 lea	 ecx, DWORD PTR _tetromino$[esp+36]
  0004d	55		 push	 ebp
  0004e	57		 push	 edi
  0004f	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue

; 14   :             if (value)

  00054	84 c0		 test	 al, al
  00056	74 57		 je	 SHORT $LN5@IsValid

; 15   :             {
; 16   :                 i32 boardRow = m_rowOffset + row;

  00058	8b 5e 10	 mov	 ebx, DWORD PTR [esi+16]
  0005b	03 df		 add	 ebx, edi

; 17   :                 i32 boardCol = m_colOffset + col;

  0005d	8b 7e 14	 mov	 edi, DWORD PTR [esi+20]
  00060	03 fd		 add	 edi, ebp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  00062	85 db		 test	 ebx, ebx
  00064	78 69		 js	 SHORT $LN10@IsValid
; File c:\dev\tetris\src\board.hpp

; 56   :             inline i32 GetBoardRows()        const { return m_boardRows; }

  00066	8b 36		 mov	 esi, DWORD PTR [esi]
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  00068	3b 5e 04	 cmp	 ebx, DWORD PTR [esi+4]
  0006b	7d 62		 jge	 SHORT $LN10@IsValid
  0006d	85 ff		 test	 edi, edi
  0006f	78 5e		 js	 SHORT $LN10@IsValid
  00071	3b 7e 08	 cmp	 edi, DWORD PTR [esi+8]
  00074	7d 59		 jge	 SHORT $LN10@IsValid
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00076	3b 5e 14	 cmp	 ebx, DWORD PTR [esi+20]
  00079	7d 07		 jge	 SHORT $LN42@IsValid
  0007b	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0007e	3b f9		 cmp	 edi, ecx
  00080	7c 17		 jl	 SHORT $LN25@IsValid
$LN42@IsValid:
  00082	6a 52		 push	 82			; 00000052H
  00084	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00089	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0008e	e8 00 00 00 00	 call	 __wassert
  00093	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN25@IsValid:
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  00099	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0009c	0f af cb	 imul	 ecx, ebx
  0009f	03 cf		 add	 ecx, edi
; File c:\dev\tetris\src\piece.cpp

; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  000a1	83 3c 88 00	 cmp	 DWORD PTR [eax+ecx*4], 0
  000a5	75 28		 jne	 SHORT $LN10@IsValid
  000a7	8b 74 24 14	 mov	 esi, DWORD PTR _this$1$[esp+32]
  000ab	8b 7c 24 10	 mov	 edi, DWORD PTR _row$1$[esp+32]
$LN5@IsValid:

; 10   :     {
; 11   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  000af	8b 44 24 1c	 mov	 eax, DWORD PTR _tetromino$[esp+36]
  000b3	45		 inc	 ebp
  000b4	3b e8		 cmp	 ebp, eax
  000b6	7c 8e		 jl	 SHORT $LL7@IsValid
$LN2@IsValid:

; 7    :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];
; 8    :     
; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  000b8	47		 inc	 edi
  000b9	89 7c 24 10	 mov	 DWORD PTR _row$1$[esp+32], edi
  000bd	3b f8		 cmp	 edi, eax
  000bf	0f 8c 7b ff ff
	ff		 jl	 $LL4@IsValid
$LN43@IsValid:

; 21   :                     m_board->GetCellValue(boardRow, boardCol))
; 22   :                 {
; 23   :                     return false;
; 24   :                 }
; 25   :             }
; 26   :         }
; 27   :     }
; 28   :     
; 29   :     return true;

  000c5	b0 01		 mov	 al, 1

; 30   : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5d		 pop	 ebp
  000ca	5b		 pop	 ebx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
$LN10@IsValid:
  000cf	5f		 pop	 edi
  000d0	32 c0		 xor	 al, al
  000d2	5e		 pop	 esi
  000d3	5d		 pop	 ebp
  000d4	5b		 pop	 ebx
  000d5	8b e5		 mov	 esp, ebp
  000d7	5d		 pop	 ebp
  000d8	c3		 ret	 0
?IsValid@Piece@gameplay@core@@QAE_NXZ ENDP		; core::gameplay::Piece::IsValid
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?GetBoardRows@Board@gameplay@core@@QBEHXZ
_TEXT	SEGMENT
?GetBoardRows@Board@gameplay@core@@QBEHXZ PROC		; core::gameplay::Board::GetBoardRows, COMDAT
; _this$ = ecx

; 56   :             inline i32 GetBoardRows()        const { return m_boardRows; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetBoardRows@Board@gameplay@core@@QBEHXZ ENDP		; core::gameplay::Board::GetBoardRows
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?GetBoardCols@Board@gameplay@core@@QBEHXZ
_TEXT	SEGMENT
?GetBoardCols@Board@gameplay@core@@QBEHXZ PROC		; core::gameplay::Board::GetBoardCols, COMDAT
; _this$ = ecx

; 55   :             inline i32 GetBoardCols()        const { return m_boardCols; }

  00000	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00003	c3		 ret	 0
?GetBoardCols@Board@gameplay@core@@QBEHXZ ENDP		; core::gameplay::Board::GetBoardCols
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?GetCellValue@Board@gameplay@core@@QBEHHH@Z
_TEXT	SEGMENT
_t_row$ = 8						; size = 4
_t_col$ = 12						; size = 4
?GetCellValue@Board@gameplay@core@@QBEHHH@Z PROC	; core::gameplay::Board::GetCellValue, COMDAT
; _this$ = ecx

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00000	53		 push	 ebx
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _t_row$[esp]
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
; File c:\dev\tetris\src\math\matrix.hpp

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00009	8b 7c 24 14	 mov	 edi, DWORD PTR _t_col$[esp+8]
  0000d	85 db		 test	 ebx, ebx
  0000f	78 10		 js	 SHORT $LN5@GetCellVal
  00011	3b 5e 14	 cmp	 ebx, DWORD PTR [esi+20]
  00014	7d 0b		 jge	 SHORT $LN5@GetCellVal
  00016	85 ff		 test	 edi, edi
  00018	78 07		 js	 SHORT $LN5@GetCellVal
  0001a	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  0001d	3b f9		 cmp	 edi, ecx
  0001f	7c 17		 jl	 SHORT $LN6@GetCellVal
$LN5@GetCellVal:
  00021	6a 52		 push	 82			; 00000052H
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0002d	e8 00 00 00 00	 call	 __wassert
  00032	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@GetCellVal:
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00038	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]
; File c:\dev\tetris\src\math\matrix.hpp

; 83   :                 return m_data[row * m_cols + col];

  0003b	0f af cb	 imul	 ecx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0003e	03 cf		 add	 ecx, edi
; File c:\dev\tetris\src\board.hpp

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx
  00043	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00046	c2 08 00	 ret	 8
?GetCellValue@Board@gameplay@core@@QBEHHH@Z ENDP	; core::gameplay::Board::GetCellValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.hpp
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?SetCellValue@Board@gameplay@core@@QAEXHHH@Z
_TEXT	SEGMENT
_t_row$ = 8						; size = 4
_t_col$ = 12						; size = 4
_t_value$ = 16						; size = 4
?SetCellValue@Board@gameplay@core@@QAEXHHH@Z PROC	; core::gameplay::Board::SetCellValue, COMDAT
; _this$ = ecx

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  00000	53		 push	 ebx
; File c:\dev\tetris\src\math\matrix.hpp

; 88   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _t_row$[esp]
; File c:\dev\tetris\src\board.hpp

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx
  00008	57		 push	 edi
; File c:\dev\tetris\src\math\matrix.hpp

; 88   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00009	8b 7c 24 14	 mov	 edi, DWORD PTR _t_col$[esp+8]
  0000d	85 db		 test	 ebx, ebx
  0000f	78 10		 js	 SHORT $LN5@SetCellVal
  00011	3b 5e 14	 cmp	 ebx, DWORD PTR [esi+20]
  00014	7d 0b		 jge	 SHORT $LN5@SetCellVal
  00016	85 ff		 test	 edi, edi
  00018	78 07		 js	 SHORT $LN5@SetCellVal
  0001a	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  0001d	3b fa		 cmp	 edi, edx
  0001f	7c 17		 jl	 SHORT $LN6@SetCellVal
$LN5@SetCellVal:
  00021	6a 58		 push	 88			; 00000058H
  00023	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00028	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0002d	e8 00 00 00 00	 call	 __wassert
  00032	8b 56 18	 mov	 edx, DWORD PTR [esi+24]
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN6@SetCellVal:

; 89   :                 m_data[row * m_cols + col] = value;

  00038	8b 4e 1c	 mov	 ecx, DWORD PTR [esi+28]
  0003b	8b 44 24 18	 mov	 eax, DWORD PTR _t_value$[esp+8]
  0003f	0f af d3	 imul	 edx, ebx
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00042	03 d7		 add	 edx, edi
; File c:\dev\tetris\src\math\matrix.hpp

; 89   :                 m_data[row * m_cols + col] = value;

  00044	5f		 pop	 edi
  00045	5e		 pop	 esi
  00046	5b		 pop	 ebx
  00047	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax
; File c:\dev\tetris\src\board.hpp

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  0004a	c2 0c 00	 ret	 12			; 0000000cH
?SetCellValue@Board@gameplay@core@@QAEXHHH@Z ENDP	; core::gameplay::Board::SetCellValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\tetromino.hpp
;	COMDAT ?GetSide@Tetromino@gameplay@core@@QBEHXZ
_TEXT	SEGMENT
?GetSide@Tetromino@gameplay@core@@QBEHXZ PROC		; core::gameplay::Tetromino::GetSide, COMDAT
; _this$ = ecx

; 28   :             inline i32 GetSide() const { return m_side; }

  00000	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00003	c3		 ret	 0
?GetSide@Tetromino@gameplay@core@@QBEHXZ ENDP		; core::gameplay::Tetromino::GetSide
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?SetValue@Matrix@math@core@@QAEXHHH@Z
_TEXT	SEGMENT
_row$ = 8						; size = 4
_col$ = 12						; size = 4
_value$ = 16						; size = 4
?SetValue@Matrix@math@core@@QAEXHHH@Z PROC		; core::math::Matrix::SetValue, COMDAT
; _this$ = ecx

; 87   :             {

  00000	53		 push	 ebx

; 88   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _col$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _row$[esp+8]
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 ff		 test	 edi, edi
  0000f	78 0f		 js	 SHORT $LN3@SetValue
  00011	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00013	7d 0b		 jge	 SHORT $LN3@SetValue
  00015	85 db		 test	 ebx, ebx
  00017	78 07		 js	 SHORT $LN3@SetValue
  00019	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  0001c	3b da		 cmp	 ebx, edx
  0001e	7c 17		 jl	 SHORT $LN4@SetValue
$LN3@SetValue:
  00020	6a 58		 push	 88			; 00000058H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0002c	e8 00 00 00 00	 call	 __wassert
  00031	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SetValue:

; 89   :                 m_data[row * m_cols + col] = value;

  00037	8b 4e 08	 mov	 ecx, DWORD PTR [esi+8]
  0003a	8b 44 24 18	 mov	 eax, DWORD PTR _value$[esp+8]
  0003e	0f af d7	 imul	 edx, edi
  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1736 : 		return (this->_Myfirst()[_Pos]);

  00043	03 d3		 add	 edx, ebx
; File c:\dev\tetris\src\math\matrix.hpp

; 89   :                 m_data[row * m_cols + col] = value;

  00045	5b		 pop	 ebx
  00046	89 04 91	 mov	 DWORD PTR [ecx+edx*4], eax

; 90   :             }

  00049	c2 0c 00	 ret	 12			; 0000000cH
?SetValue@Matrix@math@core@@QAEXHHH@Z ENDP		; core::math::Matrix::SetValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\math\matrix.hpp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?GetValue@Matrix@math@core@@QBEHHH@Z
_TEXT	SEGMENT
_row$ = 8						; size = 4
_col$ = 12						; size = 4
?GetValue@Matrix@math@core@@QBEHHH@Z PROC		; core::math::Matrix::GetValue, COMDAT
; _this$ = ecx

; 81   :             {

  00000	53		 push	 ebx

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00001	8b 5c 24 0c	 mov	 ebx, DWORD PTR _col$[esp]
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b 7c 24 10	 mov	 edi, DWORD PTR _row$[esp+8]
  0000b	8b f1		 mov	 esi, ecx
  0000d	85 ff		 test	 edi, edi
  0000f	78 0f		 js	 SHORT $LN3@GetValue
  00011	3b 3e		 cmp	 edi, DWORD PTR [esi]
  00013	7d 0b		 jge	 SHORT $LN3@GetValue
  00015	85 db		 test	 ebx, ebx
  00017	78 07		 js	 SHORT $LN3@GetValue
  00019	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0001c	3b d9		 cmp	 ebx, ecx
  0001e	7c 17		 jl	 SHORT $LN4@GetValue
$LN3@GetValue:
  00020	6a 52		 push	 82			; 00000052H
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  0002c	e8 00 00 00 00	 call	 __wassert
  00031	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GetValue:

; 83   :                 return m_data[row * m_cols + col];

  00037	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003a	0f af cf	 imul	 ecx, edi
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector

; 1745 : 		return (this->_Myfirst()[_Pos]);

  0003f	03 cb		 add	 ecx, ebx
; File c:\dev\tetris\src\math\matrix.hpp

; 83   :                 return m_data[row * m_cols + col];

  00041	5b		 pop	 ebx
  00042	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]

; 84   :             }

  00045	c2 08 00	 ret	 8
?GetValue@Matrix@math@core@@QBEHHH@Z ENDP		; core::math::Matrix::GetValue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1741 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1742 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1743 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1744 : 
; 1745 : 		return (this->_Myfirst()[_Pos]);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00006	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1746 : 		}

  00009	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00000	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00002	8b 44 24 04	 mov	 eax, DWORD PTR __Pos$[esp-4]
  00006	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]

; 1737 : 		}

  00009	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 307  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 308  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 302  : 		return (_Myval2);

  00000	8b c1		 mov	 eax, ecx

; 303  : 		}

  00002	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 581  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 582  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 576  : 		return (_Get_data()._Myfirst);

  00000	8b c1		 mov	 eax, ecx

; 577  : 		}

  00002	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 560  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 561  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 555  : 		return (_Mypair._Get_second());

  00000	8b c1		 mov	 eax, ecx

; 556  : 		}

  00002	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\dev\tetris\src\common_utils.h
;	COMDAT ?random_int@@YAHHH@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?random_int@@YAHHH@Z PROC				; random_int, COMDAT

; 31   : {

  00000	56		 push	 esi

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  00001	e8 00 00 00 00	 call	 _rand
  00006	8b 4c 24 0c	 mov	 ecx, DWORD PTR _max$[esp]
  0000a	8b f0		 mov	 esi, eax
  0000c	2b 4c 24 08	 sub	 ecx, DWORD PTR _min$[esp]
  00010	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00015	99		 cdq
  00016	41		 inc	 ecx
  00017	f7 f9		 idiv	 ecx
  00019	8d 48 01	 lea	 ecx, DWORD PTR [eax+1]
  0001c	8b c6		 mov	 eax, esi
  0001e	99		 cdq
  0001f	f7 f9		 idiv	 ecx
  00021	5e		 pop	 esi
  00022	03 44 24 04	 add	 eax, DWORD PTR _min$[esp-4]

; 33   : }

  00026	c3		 ret	 0
?random_int@@YAHHH@Z ENDP				; random_int
_TEXT	ENDS
END
