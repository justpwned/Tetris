; Listing generated by Microsoft (R) Optimizing Compiler Version 19.15.26726.0 

	TITLE	c:\Dev\Tetris\src\piece.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?random_int@@YAHHH@Z				; random_int
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	?GetValue@Matrix@math@core@@QBEHHH@Z		; core::math::Matrix::GetValue
PUBLIC	?SetValue@Matrix@math@core@@QAEXHHH@Z		; core::math::Matrix::SetValue
PUBLIC	?GetSide@Tetromino@gameplay@core@@QBEHXZ	; core::gameplay::Tetromino::GetSide
PUBLIC	?SetCellValue@Board@gameplay@core@@QAEXHHH@Z	; core::gameplay::Board::SetCellValue
PUBLIC	?GetCellValue@Board@gameplay@core@@QBEHHH@Z	; core::gameplay::Board::GetCellValue
PUBLIC	?GetBoardCols@Board@gameplay@core@@QBEHXZ	; core::gameplay::Board::GetBoardCols
PUBLIC	?GetBoardRows@Board@gameplay@core@@QBEHXZ	; core::gameplay::Board::GetBoardRows
PUBLIC	?IsValid@Piece@gameplay@core@@QAE_NXZ		; core::gameplay::Piece::IsValid
PUBLIC	?MergeWithBoard@Piece@gameplay@core@@QAEXXZ	; core::gameplay::Piece::MergeWithBoard
PUBLIC	?HardDrop@Piece@gameplay@core@@QAEXXZ		; core::gameplay::Piece::HardDrop
PUBLIC	?SoftDrop@Piece@gameplay@core@@QAE_NXZ		; core::gameplay::Piece::SoftDrop
PUBLIC	?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ	; core::gameplay::Piece::SpawnNewPiece
PUBLIC	?DrawPiece@Piece@gameplay@core@@QAEXHH_N@Z	; core::gameplay::Piece::DrawPiece
PUBLIC	??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@ ; `string'
PUBLIC	??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@ ; `string'
EXTRN	_rand:PROC
EXTRN	__wassert:PROC
EXTRN	?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z:PROC ; core::gameplay::Tetromino::GetValue
EXTRN	?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ:PROC ; core::gameplay::Stats::GetTimeToNextDrop
EXTRN	?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z:PROC ; core::gameplay::Board::DrawCell
EXTRN	?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B:BYTE ; core::gameplay::Tetromino::s_tetrominos
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
CONST	SEGMENT
??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@ DB 'r'
	DB	00H, 'o', 00H, 'w', 00H, ' ', 00H, '>', 00H, '=', 00H, ' ', 00H
	DB	'0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'r', 00H, 'o'
	DB	00H, 'w', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H
	DB	'r', 00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'l', 00H, ' ', 00H, '>', 00H
	DB	'=', 00H, '0', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, 'c'
	DB	00H, 'o', 00H, 'l', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H
	DB	'_', 00H, 'c', 00H, 'o', 00H, 'l', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
CONST	SEGMENT
??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'd', 00H, 'e', 00H, 'v', 00H, '\', 00H
	DB	't', 00H, 'e', 00H, 't', 00H, 'r', 00H, 'i', 00H, 's', 00H, '\'
	DB	00H, 's', 00H, 'r', 00H, 'c', 00H, '\', 00H, 'm', 00H, 'a', 00H
	DB	't', 00H, 'h', 00H, '\', 00H, 'm', 00H, 'a', 00H, 't', 00H, 'r'
	DB	00H, 'i', 00H, 'x', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\piece.cpp
_TEXT	SEGMENT
_tetromino$ = -24					; size = 8
_value$1 = -16						; size = 4
_this$ = -12						; size = 4
_row$2 = -8						; size = 4
_col$3 = -4						; size = 4
_t_xOffset$ = 8						; size = 4
_t_yOffset$ = 12					; size = 4
_outline$ = 16						; size = 1
?DrawPiece@Piece@gameplay@core@@QAEXHH_N@Z PROC		; core::gameplay::Piece::DrawPiece
; _this$ = ecx

; 82   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8]
  00016	8b 04 cd 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8+4]
  0001d	89 55 e8	 mov	 DWORD PTR _tetromino$[ebp], edx
  00020	89 45 ec	 mov	 DWORD PTR _tetromino$[ebp+4], eax

; 84   :     
; 85   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _row$2[ebp], 0
  0002a	eb 09		 jmp	 SHORT $LN4@DrawPiece
$LN2@DrawPiece:
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _row$2[ebp]
  0002f	83 c1 01	 add	 ecx, 1
  00032	89 4d f8	 mov	 DWORD PTR _row$2[ebp], ecx
$LN4@DrawPiece:
  00035	8d 4d e8	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  00038	e8 00 00 00 00	 call	 ?GetSide@Tetromino@gameplay@core@@QBEHXZ ; core::gameplay::Tetromino::GetSide
  0003d	39 45 f8	 cmp	 DWORD PTR _row$2[ebp], eax
  00040	7d 78		 jge	 SHORT $LN1@DrawPiece

; 86   :     {
; 87   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _col$3[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN7@DrawPiece
$LN5@DrawPiece:
  0004b	8b 55 fc	 mov	 edx, DWORD PTR _col$3[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 fc	 mov	 DWORD PTR _col$3[ebp], edx
$LN7@DrawPiece:
  00054	8d 4d e8	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  00057	e8 00 00 00 00	 call	 ?GetSide@Tetromino@gameplay@core@@QBEHXZ ; core::gameplay::Tetromino::GetSide
  0005c	39 45 fc	 cmp	 DWORD PTR _col$3[ebp], eax
  0005f	7d 54		 jge	 SHORT $LN6@DrawPiece

; 88   :         {
; 89   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00061	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00067	51		 push	 ecx
  00068	8b 55 fc	 mov	 edx, DWORD PTR _col$3[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 f8	 mov	 eax, DWORD PTR _row$2[ebp]
  0006f	50		 push	 eax
  00070	8d 4d e8	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  00073	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	89 4d f0	 mov	 DWORD PTR _value$1[ebp], ecx

; 90   :             if (value)

  0007e	83 7d f0 00	 cmp	 DWORD PTR _value$1[ebp], 0
  00082	74 2f		 je	 SHORT $LN8@DrawPiece

; 91   :             {
; 92   :                 m_board->DrawCell(row + m_rowOffset, col + m_colOffset, value, t_xOffset, t_yOffset, outline);

  00084	0f b6 55 10	 movzx	 edx, BYTE PTR _outline$[ebp]
  00088	52		 push	 edx
  00089	8b 45 0c	 mov	 eax, DWORD PTR _t_yOffset$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _t_xOffset$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 f0	 mov	 edx, DWORD PTR _value$1[ebp]
  00094	52		 push	 edx
  00095	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00098	8b 4d fc	 mov	 ecx, DWORD PTR _col$3[ebp]
  0009b	03 48 14	 add	 ecx, DWORD PTR [eax+20]
  0009e	51		 push	 ecx
  0009f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000a2	8b 45 f8	 mov	 eax, DWORD PTR _row$2[ebp]
  000a5	03 42 10	 add	 eax, DWORD PTR [edx+16]
  000a8	50		 push	 eax
  000a9	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000ae	e8 00 00 00 00	 call	 ?DrawCell@Board@gameplay@core@@QAEXHHHHH_N@Z ; core::gameplay::Board::DrawCell
$LN8@DrawPiece:

; 93   :             }
; 94   :         }

  000b3	eb 96		 jmp	 SHORT $LN5@DrawPiece
$LN6@DrawPiece:

; 95   :     }

  000b5	e9 72 ff ff ff	 jmp	 $LN2@DrawPiece
$LN1@DrawPiece:

; 96   : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 0c 00	 ret	 12			; 0000000cH
?DrawPiece@Piece@gameplay@core@@QAEXHH_N@Z ENDP		; core::gameplay::Piece::DrawPiece
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\piece.cpp
_TEXT	SEGMENT
tv135 = -8						; size = 4
_this$ = -4						; size = 4
?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ PROC		; core::gameplay::Piece::SpawnNewPiece
; _this$ = ecx

; 73   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 74   :     m_tetrominoIndex = random_int(0, Tetromino::s_numberOfTetrominos - 1);

  0000a	6a 06		 push	 6
  0000c	6a 00		 push	 0
  0000e	e8 00 00 00 00	 call	 ?random_int@@YAHHH@Z	; random_int
  00013	83 c4 08	 add	 esp, 8
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 75   :     m_colOffset = m_board->GetBoardCols() / 2 - 1;

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00021	e8 00 00 00 00	 call	 ?GetBoardCols@Board@gameplay@core@@QBEHXZ ; core::gameplay::Board::GetBoardCols
  00026	99		 cdq
  00027	2b c2		 sub	 eax, edx
  00029	d1 f8		 sar	 eax, 1
  0002b	83 e8 01	 sub	 eax, 1
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 76   :     m_rowOffset = 0;

  00034	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00037	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 77   :     m_rotation = 0;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 78   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  00048	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00051	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00054	e8 00 00 00 00	 call	 ?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ ; core::gameplay::Stats::GetTimeToNextDrop
  00059	d9 5d f8	 fstp	 DWORD PTR tv135[ebp]
  0005c	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv135[ebp]
  00061	f3 0f 58 46 08	 addss	 xmm0, DWORD PTR [esi+8]
  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 79   : }

  00070	5e		 pop	 esi
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ ENDP		; core::gameplay::Piece::SpawnNewPiece
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\piece.cpp
_TEXT	SEGMENT
tv131 = -8						; size = 4
_this$ = -4						; size = 4
?SoftDrop@Piece@gameplay@core@@QAE_NXZ PROC		; core::gameplay::Piece::SoftDrop
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 58   :     ++m_rowOffset;

  0000a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00010	83 c1 01	 add	 ecx, 1
  00013	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00016	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 59   :     if (!IsValid())

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?IsValid@Piece@gameplay@core@@QAE_NXZ ; core::gameplay::Piece::IsValid
  00021	0f b6 c0	 movzx	 eax, al
  00024	85 c0		 test	 eax, eax
  00026	75 23		 jne	 SHORT $LN2@SoftDrop

; 60   :     {
; 61   :         --m_rowOffset;

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0002e	83 ea 01	 sub	 edx, 1
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 62   :         MergeWithBoard();

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?MergeWithBoard@Piece@gameplay@core@@QAEXXZ ; core::gameplay::Piece::MergeWithBoard

; 63   :         SpawnNewPiece();

  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?SpawnNewPiece@Piece@gameplay@core@@QAEXXZ ; core::gameplay::Piece::SpawnNewPiece

; 64   :         
; 65   :         return false;

  00047	32 c0		 xor	 al, al
  00049	eb 2a		 jmp	 SHORT $LN1@SoftDrop
$LN2@SoftDrop:

; 66   :     }
; 67   :     
; 68   :     m_time->nextDropTime = m_time->time + m_stats->GetTimeToNextDrop();

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	8b 71 04	 mov	 esi, DWORD PTR [ecx+4]
  00051	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00054	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00057	e8 00 00 00 00	 call	 ?GetTimeToNextDrop@Stats@gameplay@core@@QAEMXZ ; core::gameplay::Stats::GetTimeToNextDrop
  0005c	d9 5d f8	 fstp	 DWORD PTR tv131[ebp]
  0005f	f3 0f 10 45 f8	 movss	 xmm0, DWORD PTR tv131[ebp]
  00064	f3 0f 58 46 08	 addss	 xmm0, DWORD PTR [esi+8]
  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006f	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 69   :     return true;

  00073	b0 01		 mov	 al, 1
$LN1@SoftDrop:

; 70   : }

  00075	5e		 pop	 esi
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
?SoftDrop@Piece@gameplay@core@@QAE_NXZ ENDP		; core::gameplay::Piece::SoftDrop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\piece.cpp
_TEXT	SEGMENT
_this$ = -4						; size = 4
?HardDrop@Piece@gameplay@core@@QAEXXZ PROC		; core::gameplay::Piece::HardDrop
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
$LN2@HardDrop:

; 34   :     while (SoftDrop());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?SoftDrop@Piece@gameplay@core@@QAE_NXZ ; core::gameplay::Piece::SoftDrop
  0000f	0f b6 c0	 movzx	 eax, al
  00012	85 c0		 test	 eax, eax
  00014	74 02		 je	 SHORT $LN1@HardDrop
  00016	eb ef		 jmp	 SHORT $LN2@HardDrop
$LN1@HardDrop:

; 35   : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?HardDrop@Piece@gameplay@core@@QAEXXZ ENDP		; core::gameplay::Piece::HardDrop
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\piece.cpp
_TEXT	SEGMENT
_tetromino$ = -32					; size = 8
_boardRow$1 = -24					; size = 4
_boardCol$2 = -20					; size = 4
_value$3 = -16						; size = 4
_this$ = -12						; size = 4
_col$4 = -8						; size = 4
_row$5 = -4						; size = 4
?MergeWithBoard@Piece@gameplay@core@@QAEXXZ PROC	; core::gameplay::Piece::MergeWithBoard
; _this$ = ecx

; 38   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8]
  00016	8b 04 cd 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8+4]
  0001d	89 55 e0	 mov	 DWORD PTR _tetromino$[ebp], edx
  00020	89 45 e4	 mov	 DWORD PTR _tetromino$[ebp+4], eax

; 40   :     
; 41   :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00023	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _row$5[ebp], 0
  0002a	eb 09		 jmp	 SHORT $LN4@MergeWithB
$LN2@MergeWithB:
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _row$5[ebp]
  0002f	83 c1 01	 add	 ecx, 1
  00032	89 4d fc	 mov	 DWORD PTR _row$5[ebp], ecx
$LN4@MergeWithB:
  00035	8d 4d e0	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  00038	e8 00 00 00 00	 call	 ?GetSide@Tetromino@gameplay@core@@QBEHXZ ; core::gameplay::Tetromino::GetSide
  0003d	39 45 fc	 cmp	 DWORD PTR _row$5[ebp], eax
  00040	7d 77		 jge	 SHORT $LN1@MergeWithB

; 42   :     {
; 43   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _col$4[ebp], 0
  00049	eb 09		 jmp	 SHORT $LN7@MergeWithB
$LN5@MergeWithB:
  0004b	8b 55 f8	 mov	 edx, DWORD PTR _col$4[ebp]
  0004e	83 c2 01	 add	 edx, 1
  00051	89 55 f8	 mov	 DWORD PTR _col$4[ebp], edx
$LN7@MergeWithB:
  00054	8d 4d e0	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  00057	e8 00 00 00 00	 call	 ?GetSide@Tetromino@gameplay@core@@QBEHXZ ; core::gameplay::Tetromino::GetSide
  0005c	39 45 f8	 cmp	 DWORD PTR _col$4[ebp], eax
  0005f	7d 53		 jge	 SHORT $LN6@MergeWithB

; 44   :         {
; 45   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00061	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00064	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00067	51		 push	 ecx
  00068	8b 55 f8	 mov	 edx, DWORD PTR _col$4[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 fc	 mov	 eax, DWORD PTR _row$5[ebp]
  0006f	50		 push	 eax
  00070	8d 4d e0	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  00073	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	89 4d f0	 mov	 DWORD PTR _value$3[ebp], ecx

; 46   :             if (value)

  0007e	83 7d f0 00	 cmp	 DWORD PTR _value$3[ebp], 0
  00082	74 2e		 je	 SHORT $LN8@MergeWithB

; 47   :             {
; 48   :                 i32 boardRow = m_rowOffset + row;

  00084	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00087	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0008a	03 45 fc	 add	 eax, DWORD PTR _row$5[ebp]
  0008d	89 45 e8	 mov	 DWORD PTR _boardRow$1[ebp], eax

; 49   :                 i32 boardCol = m_colOffset + col;

  00090	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00096	03 55 f8	 add	 edx, DWORD PTR _col$4[ebp]
  00099	89 55 ec	 mov	 DWORD PTR _boardCol$2[ebp], edx

; 50   :                 m_board->SetCellValue(boardRow, boardCol, value);

  0009c	8b 45 f0	 mov	 eax, DWORD PTR _value$3[ebp]
  0009f	50		 push	 eax
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _boardCol$2[ebp]
  000a3	51		 push	 ecx
  000a4	8b 55 e8	 mov	 edx, DWORD PTR _boardRow$1[ebp]
  000a7	52		 push	 edx
  000a8	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ab	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ad	e8 00 00 00 00	 call	 ?SetCellValue@Board@gameplay@core@@QAEXHHH@Z ; core::gameplay::Board::SetCellValue
$LN8@MergeWithB:

; 51   :             }
; 52   :         }

  000b2	eb 97		 jmp	 SHORT $LN5@MergeWithB
$LN6@MergeWithB:

; 53   :     }

  000b4	e9 73 ff ff ff	 jmp	 $LN2@MergeWithB
$LN1@MergeWithB:

; 54   : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
?MergeWithBoard@Piece@gameplay@core@@QAEXXZ ENDP	; core::gameplay::Piece::MergeWithBoard
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\piece.cpp
_TEXT	SEGMENT
_tetromino$ = -32					; size = 8
_value$1 = -24						; size = 4
_boardRow$2 = -20					; size = 4
_boardCol$3 = -16					; size = 4
_col$4 = -12						; size = 4
_row$5 = -8						; size = 4
_this$ = -4						; size = 4
?IsValid@Piece@gameplay@core@@QAE_NXZ PROC		; core::gameplay::Piece::IsValid
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 7    :     Tetromino tetromino = Tetromino::s_tetrominos[m_tetrominoIndex];

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000f	8b 14 cd 00 00
	00 00		 mov	 edx, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8]
  00016	8b 04 cd 04 00
	00 00		 mov	 eax, DWORD PTR ?s_tetrominos@Tetromino@gameplay@core@@2QBV123@B[ecx*8+4]
  0001d	89 55 e0	 mov	 DWORD PTR _tetromino$[ebp], edx
  00020	89 45 e4	 mov	 DWORD PTR _tetromino$[ebp+4], eax

; 8    :     
; 9    :     for (i32 row = 0; row < tetromino.GetSide(); ++row)

  00023	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _row$5[ebp], 0
  0002a	eb 09		 jmp	 SHORT $LN4@IsValid
$LN2@IsValid:
  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _row$5[ebp]
  0002f	83 c1 01	 add	 ecx, 1
  00032	89 4d f8	 mov	 DWORD PTR _row$5[ebp], ecx
$LN4@IsValid:
  00035	8d 4d e0	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  00038	e8 00 00 00 00	 call	 ?GetSide@Tetromino@gameplay@core@@QBEHXZ ; core::gameplay::Tetromino::GetSide
  0003d	39 45 f8	 cmp	 DWORD PTR _row$5[ebp], eax
  00040	0f 8d ac 00 00
	00		 jge	 $LN3@IsValid

; 10   :     {
; 11   :         for (i32 col = 0; col < tetromino.GetSide(); ++col)

  00046	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _col$4[ebp], 0
  0004d	eb 09		 jmp	 SHORT $LN7@IsValid
$LN5@IsValid:
  0004f	8b 55 f4	 mov	 edx, DWORD PTR _col$4[ebp]
  00052	83 c2 01	 add	 edx, 1
  00055	89 55 f4	 mov	 DWORD PTR _col$4[ebp], edx
$LN7@IsValid:
  00058	8d 4d e0	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  0005b	e8 00 00 00 00	 call	 ?GetSide@Tetromino@gameplay@core@@QBEHXZ ; core::gameplay::Tetromino::GetSide
  00060	39 45 f4	 cmp	 DWORD PTR _col$4[ebp], eax
  00063	0f 8d 84 00 00
	00		 jge	 $LN6@IsValid

; 12   :         {
; 13   :             i32 value = tetromino.GetValue(row, col, m_rotation);

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0006f	51		 push	 ecx
  00070	8b 55 f4	 mov	 edx, DWORD PTR _col$4[ebp]
  00073	52		 push	 edx
  00074	8b 45 f8	 mov	 eax, DWORD PTR _row$5[ebp]
  00077	50		 push	 eax
  00078	8d 4d e0	 lea	 ecx, DWORD PTR _tetromino$[ebp]
  0007b	e8 00 00 00 00	 call	 ?GetValue@Tetromino@gameplay@core@@QAEEHHH@Z ; core::gameplay::Tetromino::GetValue
  00080	0f b6 c8	 movzx	 ecx, al
  00083	89 4d e8	 mov	 DWORD PTR _value$1[ebp], ecx

; 14   :             if (value)

  00086	83 7d e8 00	 cmp	 DWORD PTR _value$1[ebp], 0
  0008a	74 5c		 je	 SHORT $LN8@IsValid

; 15   :             {
; 16   :                 i32 boardRow = m_rowOffset + row;

  0008c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0008f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00092	03 45 f8	 add	 eax, DWORD PTR _row$5[ebp]
  00095	89 45 ec	 mov	 DWORD PTR _boardRow$2[ebp], eax

; 17   :                 i32 boardCol = m_colOffset + col;

  00098	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0009e	03 55 f4	 add	 edx, DWORD PTR _col$4[ebp]
  000a1	89 55 f0	 mov	 DWORD PTR _boardCol$3[ebp], edx

; 18   :                 
; 19   :                 if (boardRow < 0 || boardRow >= m_board->GetBoardRows() ||
; 20   :                     boardCol < 0 || boardCol >= m_board->GetBoardCols() ||

  000a4	83 7d ec 00	 cmp	 DWORD PTR _boardRow$2[ebp], 0
  000a8	7c 3a		 jl	 SHORT $LN10@IsValid
  000aa	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  000af	e8 00 00 00 00	 call	 ?GetBoardRows@Board@gameplay@core@@QBEHXZ ; core::gameplay::Board::GetBoardRows
  000b4	39 45 ec	 cmp	 DWORD PTR _boardRow$2[ebp], eax
  000b7	7d 2b		 jge	 SHORT $LN10@IsValid
  000b9	83 7d f0 00	 cmp	 DWORD PTR _boardCol$3[ebp], 0
  000bd	7c 25		 jl	 SHORT $LN10@IsValid
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000c2	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000c4	e8 00 00 00 00	 call	 ?GetBoardCols@Board@gameplay@core@@QBEHXZ ; core::gameplay::Board::GetBoardCols
  000c9	39 45 f0	 cmp	 DWORD PTR _boardCol$3[ebp], eax
  000cc	7d 16		 jge	 SHORT $LN10@IsValid
  000ce	8b 55 f0	 mov	 edx, DWORD PTR _boardCol$3[ebp]
  000d1	52		 push	 edx
  000d2	8b 45 ec	 mov	 eax, DWORD PTR _boardRow$2[ebp]
  000d5	50		 push	 eax
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d9	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000db	e8 00 00 00 00	 call	 ?GetCellValue@Board@gameplay@core@@QBEHHH@Z ; core::gameplay::Board::GetCellValue
  000e0	85 c0		 test	 eax, eax
  000e2	74 04		 je	 SHORT $LN8@IsValid
$LN10@IsValid:

; 21   :                     m_board->GetCellValue(boardRow, boardCol))
; 22   :                 {
; 23   :                     return false;

  000e4	32 c0		 xor	 al, al
  000e6	eb 0c		 jmp	 SHORT $LN1@IsValid
$LN8@IsValid:

; 24   :                 }
; 25   :             }
; 26   :         }

  000e8	e9 62 ff ff ff	 jmp	 $LN5@IsValid
$LN6@IsValid:

; 27   :     }

  000ed	e9 3a ff ff ff	 jmp	 $LN2@IsValid
$LN3@IsValid:

; 28   :     
; 29   :     return true;

  000f2	b0 01		 mov	 al, 1
$LN1@IsValid:

; 30   : }

  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
?IsValid@Piece@gameplay@core@@QAE_NXZ ENDP		; core::gameplay::Piece::IsValid
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?GetBoardRows@Board@gameplay@core@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBoardRows@Board@gameplay@core@@QBEHXZ PROC		; core::gameplay::Board::GetBoardRows, COMDAT
; _this$ = ecx

; 56   :             inline i32 GetBoardRows()        const { return m_boardRows; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetBoardRows@Board@gameplay@core@@QBEHXZ ENDP		; core::gameplay::Board::GetBoardRows
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?GetBoardCols@Board@gameplay@core@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetBoardCols@Board@gameplay@core@@QBEHXZ PROC		; core::gameplay::Board::GetBoardCols, COMDAT
; _this$ = ecx

; 55   :             inline i32 GetBoardCols()        const { return m_boardCols; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetBoardCols@Board@gameplay@core@@QBEHXZ ENDP		; core::gameplay::Board::GetBoardCols
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?GetCellValue@Board@gameplay@core@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t_row$ = 8						; size = 4
_t_col$ = 12						; size = 4
?GetCellValue@Board@gameplay@core@@QBEHHH@Z PROC	; core::gameplay::Board::GetCellValue, COMDAT
; _this$ = ecx

; 53   :             { return m_boardData.GetValue(t_row, t_col); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _t_col$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR _t_row$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 c1 14	 add	 ecx, 20			; 00000014H
  00015	e8 00 00 00 00	 call	 ?GetValue@Matrix@math@core@@QBEHHH@Z ; core::math::Matrix::GetValue
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?GetCellValue@Board@gameplay@core@@QBEHHH@Z ENDP	; core::gameplay::Board::GetCellValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\board.hpp
;	COMDAT ?SetCellValue@Board@gameplay@core@@QAEXHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_t_row$ = 8						; size = 4
_t_col$ = 12						; size = 4
_t_value$ = 16						; size = 4
?SetCellValue@Board@gameplay@core@@QAEXHHH@Z PROC	; core::gameplay::Board::SetCellValue, COMDAT
; _this$ = ecx

; 50   :             { m_boardData.SetValue(t_row, t_col, t_value); }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 10	 mov	 eax, DWORD PTR _t_value$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR _t_col$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR _t_row$[ebp]
  00012	52		 push	 edx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 14	 add	 ecx, 20			; 00000014H
  00019	e8 00 00 00 00	 call	 ?SetValue@Matrix@math@core@@QAEXHHH@Z ; core::math::Matrix::SetValue
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
?SetCellValue@Board@gameplay@core@@QAEXHHH@Z ENDP	; core::gameplay::Board::SetCellValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\tetromino.hpp
;	COMDAT ?GetSide@Tetromino@gameplay@core@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?GetSide@Tetromino@gameplay@core@@QBEHXZ PROC		; core::gameplay::Tetromino::GetSide, COMDAT
; _this$ = ecx

; 28   :             inline i32 GetSide() const { return m_side; }

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?GetSide@Tetromino@gameplay@core@@QBEHXZ ENDP		; core::gameplay::Tetromino::GetSide
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?SetValue@Matrix@math@core@@QAEXHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_row$ = 8						; size = 4
_col$ = 12						; size = 4
_value$ = 16						; size = 4
?SetValue@Matrix@math@core@@QAEXHHH@Z PROC		; core::math::Matrix::SetValue, COMDAT
; _this$ = ecx

; 87   :             {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 88   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00007	83 7d 08 00	 cmp	 DWORD PTR _row$[ebp], 0
  0000b	7c 1b		 jl	 SHORT $LN3@SetValue
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _row$[ebp]
  00013	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00015	7d 11		 jge	 SHORT $LN3@SetValue
  00017	83 7d 0c 00	 cmp	 DWORD PTR _col$[ebp], 0
  0001b	7c 0b		 jl	 SHORT $LN3@SetValue
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00023	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00026	7c 14		 jl	 SHORT $LN4@SetValue
$LN3@SetValue:
  00028	6a 58		 push	 88			; 00000058H
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00034	e8 00 00 00 00	 call	 __wassert
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@SetValue:

; 89   :                 m_data[row * m_cols + col] = value;

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _row$[ebp]
  00042	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  00046	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 08	 add	 ecx, 8
  00050	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  00055	8b 4d 10	 mov	 ecx, DWORD PTR _value$[ebp]
  00058	89 08		 mov	 DWORD PTR [eax], ecx

; 90   :             }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 0c 00	 ret	 12			; 0000000cH
?SetValue@Matrix@math@core@@QAEXHHH@Z ENDP		; core::math::Matrix::SetValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\math\matrix.hpp
;	COMDAT ?GetValue@Matrix@math@core@@QBEHHH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_row$ = 8						; size = 4
_col$ = 12						; size = 4
?GetValue@Matrix@math@core@@QBEHHH@Z PROC		; core::math::Matrix::GetValue, COMDAT
; _this$ = ecx

; 81   :             {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 82   :                 assert(row >= 0 && row < m_rows && col >=0 && col < m_cols);

  00007	83 7d 08 00	 cmp	 DWORD PTR _row$[ebp], 0
  0000b	7c 1b		 jl	 SHORT $LN3@GetValue
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00010	8b 4d 08	 mov	 ecx, DWORD PTR _row$[ebp]
  00013	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00015	7d 11		 jge	 SHORT $LN3@GetValue
  00017	83 7d 0c 00	 cmp	 DWORD PTR _col$[ebp], 0
  0001b	7c 0b		 jl	 SHORT $LN3@GetValue
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00020	8b 45 0c	 mov	 eax, DWORD PTR _col$[ebp]
  00023	3b 42 04	 cmp	 eax, DWORD PTR [edx+4]
  00026	7c 14		 jl	 SHORT $LN4@GetValue
$LN3@GetValue:
  00028	6a 52		 push	 82			; 00000052H
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_1EE@HDIKHOLG@?$AAc?$AA?3?$AA?2?$AAd?$AAe?$AAv?$AA?2?$AAt?$AAe?$AAt?$AAr?$AAi?$AAs?$AA?2?$AAs@
  0002f	68 00 00 00 00	 push	 OFFSET ??_C@_1GI@GGOBNHPI@?$AAr?$AAo?$AAw?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAr?$AAo?$AAw@
  00034	e8 00 00 00 00	 call	 __wassert
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@GetValue:

; 83   :                 return m_data[row * m_cols + col];

  0003c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003f	8b 45 08	 mov	 eax, DWORD PTR _row$[ebp]
  00042	0f af 42 04	 imul	 eax, DWORD PTR [edx+4]
  00046	03 45 0c	 add	 eax, DWORD PTR _col$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 08	 add	 ecx, 8
  00050	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  00055	8b 00		 mov	 eax, DWORD PTR [eax]

; 84   :             }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 08 00	 ret	 8
?GetValue@Matrix@math@core@@QBEHHH@Z ENDP		; core::math::Matrix::GetValue
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1740 : 		{	// subscript nonmutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1741 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1742 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1743 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1744 : 
; 1745 : 		return (this->_Myfirst()[_Pos]);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00014	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1746 : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QBEABHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1731 : 		{	// subscript mutable sequence

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1732 :  #if _ITERATOR_DEBUG_LEVEL != 0
; 1733 : 		_STL_VERIFY(_Pos < size(), "vector subscript out of range");
; 1734 :  #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 1735 : 
; 1736 : 		return (this->_Myfirst()[_Pos]);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
  0000f	8b 00		 mov	 eax, DWORD PTR [eax]
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Pos$[ebp]
  00014	8d 04 88	 lea	 eax, DWORD PTR [eax+ecx*4]

; 1737 : 		}

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 306  : 		{	// return const reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 307  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 301  : 		{	// return reference to second

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 302  : 		return (_Myval2);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 303  : 		}

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 580  : 		{	// return const reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 581  : 		return (_Get_data()._Myfirst);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data

; 582  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABQAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 575  : 		{	// return reference to _Myfirst

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 576  : 		return (_Get_data()._Myfirst);

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data

; 577  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 559  : 		{	// return const reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  : 		return (_Mypair._Get_second());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second

; 561  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio\2017\community\vc\tools\msvc\14.15.26726\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 554  : 		{	// return reference to _Vector_val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 555  : 		return (_Mypair._Get_second());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_second@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second

; 556  : 		}

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp
; File c:\dev\tetris\src\common_utils.h
;	COMDAT ?random_int@@YAHHH@Z
_TEXT	SEGMENT
_min$ = 8						; size = 4
_max$ = 12						; size = 4
?random_int@@YAHHH@Z PROC				; random_int, COMDAT

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 32   :     return min + rand() / (RAND_MAX / (max - min + 1) + 1);

  00004	e8 00 00 00 00	 call	 _rand
  00009	8b c8		 mov	 ecx, eax
  0000b	8b 75 0c	 mov	 esi, DWORD PTR _max$[ebp]
  0000e	2b 75 08	 sub	 esi, DWORD PTR _min$[ebp]
  00011	83 c6 01	 add	 esi, 1
  00014	b8 ff 7f 00 00	 mov	 eax, 32767		; 00007fffH
  00019	99		 cdq
  0001a	f7 fe		 idiv	 esi
  0001c	8b f0		 mov	 esi, eax
  0001e	83 c6 01	 add	 esi, 1
  00021	8b c1		 mov	 eax, ecx
  00023	99		 cdq
  00024	f7 fe		 idiv	 esi
  00026	03 45 08	 add	 eax, DWORD PTR _min$[ebp]

; 33   : }

  00029	5e		 pop	 esi
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?random_int@@YAHHH@Z ENDP				; random_int
_TEXT	ENDS
END
